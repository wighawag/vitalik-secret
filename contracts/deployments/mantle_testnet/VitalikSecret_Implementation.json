{
  "address": "0x21d366ee3bbf67ab057c517380d37e54ffd9dfc0",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "addr",
          "type": "address"
        }
      ],
      "name": "InvalidAddress",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenID",
          "type": "uint256"
        }
      ],
      "name": "NonExistentToken",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NonceOverflow",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NotAuthorized",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "provided",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "currentOwner",
          "type": "address"
        }
      ],
      "name": "NotOwner",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "TransferRejected",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "approved",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenID",
          "type": "uint256"
        }
      ],
      "name": "Approval",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "approved",
          "type": "bool"
        }
      ],
      "name": "ApprovalForAll",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenID",
          "type": "uint256"
        }
      ],
      "name": "Transfer",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "SIZE",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenID",
          "type": "uint256"
        }
      ],
      "name": "approve",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "name": "balanceOf",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "balance",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "_bytes32",
          "type": "bytes32"
        }
      ],
      "name": "bytes32ToHexString",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenID",
          "type": "uint256"
        }
      ],
      "name": "getApproved",
      "outputs": [
        {
          "internalType": "address",
          "name": "operator",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "operator",
          "type": "address"
        }
      ],
      "name": "isApprovedForAll",
      "outputs": [
        {
          "internalType": "bool",
          "name": "isOperator",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "lowestNumberOfMoves",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "name",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256[]",
          "name": "tokenIDs",
          "type": "uint256[]"
        }
      ],
      "name": "ownerAndLastTransferBlockNumberList",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "owner",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "lastTransferBlockNumber",
              "type": "uint256"
            }
          ],
          "internalType": "struct IERC721WithBlocknumber.OwnerData[]",
          "name": "ownersData",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenID",
          "type": "uint256"
        }
      ],
      "name": "ownerAndLastTransferBlockNumberOf",
      "outputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "blockNumber",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenID",
          "type": "uint256"
        }
      ],
      "name": "ownerOf",
      "outputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "enum VitalikSecret.Move[]",
          "name": "moves",
          "type": "uint8[]"
        }
      ],
      "name": "proposeSolution",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "numMoves",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "proof",
          "type": "bytes"
        }
      ],
      "name": "proposeSolutionProof",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "randomState",
      "outputs": [
        {
          "internalType": "uint8[16]",
          "name": "",
          "type": "uint8[16]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenID",
          "type": "uint256"
        }
      ],
      "name": "safeTransferFrom",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenID",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "safeTransferFrom",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "approved",
          "type": "bool"
        }
      ],
      "name": "setApprovalForAll",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "interfaceID",
          "type": "bytes4"
        }
      ],
      "name": "supportsInterface",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "symbol",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "numMoves",
          "type": "uint256"
        }
      ],
      "name": "testMint",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenID",
          "type": "uint256"
        }
      ],
      "name": "tokenURI",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenID",
          "type": "uint256"
        }
      ],
      "name": "transferFrom",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "contractName": "VitalikSecret",
  "sourceName": "src/VitalikSecret.sol",
  "bytecode": "0x60c06040526007608052600a60a05234801561001a57600080fd5b5060805160a051612a1061004e60003960008181610fa401528181611047015261111301526000610eb40152612a106000f3fe608060405234801561001057600080fd5b50600436106101825760003560e01c80639e06c90b116100d8578063c68b37871161008c578063f394528211610066578063f394528214610403578063f66168c814610423578063fd82234c1461043857600080fd5b8063c68b378714610394578063c87b56dd146103a7578063e985e9c5146103ba57600080fd5b8063b88d4fde116100bd578063b88d4fde14610366578063bdffd28214610379578063c370c3c71461038157600080fd5b80639e06c90b14610340578063a22cb4651461035357600080fd5b80632f3f94ae1161013a5780636352211e116101145780636352211e146102d357806370a08231146102e657806395d89b411461030757600080fd5b80632f3f94ae1461025157806342842e0e1461026457806348f3c51c1461027757600080fd5b8063081812fc1161016b578063081812fc146101f1578063095ea7b31461022957806323b872dd1461023e57600080fd5b806301ffc9a71461018757806306fdde03146101af575b600080fd5b61019a610195366004612024565b610441565b60405190151581526020015b60405180910390f35b60408051808201909152600e81527f564954414c494b2053454352455400000000000000000000000000000000000060208201525b6040516101a691906120b6565b6102046101ff3660046120c9565b610526565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020016101a6565b61023c610237366004612106565b6105ea565b005b61023c61024c366004612130565b6106fb565b61023c61025f3660046120c9565b610979565b61023c610272366004612130565b6109a1565b6102a76102853660046120c9565b6000908152602081905260409020549067ffffffffffffffff60b883901c1690565b6040805173ffffffffffffffffffffffffffffffffffffffff90931683526020830191909152016101a6565b6102046102e13660046120c9565b6109c1565b6102f96102f436600461216c565b610a25565b6040519081526020016101a6565b60408051808201909152600381527f565453000000000000000000000000000000000000000000000000000000000060208201526101e4565b61023c61034e366004612187565b610ab5565b61023c610361366004612203565b610b9f565b61023c61037436600461226e565b610bae565b6102f9600481565b61023c61038f3660046123b4565b610e2e565b6101e46103a23660046120c9565b61125f565b6101e46103b53660046120c9565b6114eb565b61019a6103c83660046123f6565b73ffffffffffffffffffffffffffffffffffffffff918216600090815260026020908152604080832093909416825291909152205460ff1690565b6104166104113660046123b4565b611556565b6040516101a69190612429565b61042b61168d565b6040516101a6919061248e565b6102f960055481565b60007f01ffc9a7000000000000000000000000000000000000000000000000000000007fffffffff00000000000000000000000000000000000000000000000000000000831614806104d457507f80ac58cd000000000000000000000000000000000000000000000000000000007fffffffff000000000000000000000000000000000000000000000000000000008316145b8061052057507f5b5e139f000000000000000000000000000000000000000000000000000000007fffffffff000000000000000000000000000000000000000000000000000000008316145b92915050565b6000818152602081905260408120547f80000000000000000000000000000000000000000000000000000000000000008082161473ffffffffffffffffffffffffffffffffffffffff82166105af576040517f38077a2b000000000000000000000000000000000000000000000000000000008152600481018590526024015b60405180910390fd5b80156105e05750505060009081526003602052604090205473ffffffffffffffffffffffffffffffffffffffff1690565b5060009392505050565b6000818152602081905260409020546affffffffffffffffffffff60a082901c1673ffffffffffffffffffffffffffffffffffffffff821661065b576040517f38077a2b000000000000000000000000000000000000000000000000000000008152600481018490526024016105a6565b3373ffffffffffffffffffffffffffffffffffffffff8316148015906106b2575073ffffffffffffffffffffffffffffffffffffffff8216600090815260026020908152604080832033845290915290205460ff16155b156106e9576040517fea8e4eb500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6106f5828286866117f9565b50505050565b6000818152602081905260409020546affffffffffffffffffffff60a082901c167f80000000000000000000000000000000000000000000000000000000000000008083161473ffffffffffffffffffffffffffffffffffffffff8316610791576040517f38077a2b000000000000000000000000000000000000000000000000000000008152600481018590526024016105a6565b8273ffffffffffffffffffffffffffffffffffffffff168673ffffffffffffffffffffffffffffffffffffffff1614610816576040517f23295f0e00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8088166004830152841660248201526044016105a6565b73ffffffffffffffffffffffffffffffffffffffff8516158061084e575073ffffffffffffffffffffffffffffffffffffffff851630145b1561089d576040517f8e4c8aa600000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff861660048201526024016105a6565b3373ffffffffffffffffffffffffffffffffffffffff87161461095f578080156108ea575060008481526003602052604090205473ffffffffffffffffffffffffffffffffffffffff1633145b158015610928575073ffffffffffffffffffffffffffffffffffffffff8616600090815260026020908152604080832033845290915290205460ff16155b1561095f576040517fea8e4eb500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b610971868686601886901c1515611982565b505050505050565b6005541580610989575060055481105b156109945760058190555b61099e3382611a65565b50565b6109bc83838360405180602001604052806000815250610bae565b505050565b60008181526020819052604090205473ffffffffffffffffffffffffffffffffffffffff8116610a20576040517f38077a2b000000000000000000000000000000000000000000000000000000008152600481018390526024016105a6565b919050565b600073ffffffffffffffffffffffffffffffffffffffff8216610a8c576040517f8e4c8aa600000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff831660048201526024016105a6565b5073ffffffffffffffffffffffffffffffffffffffff1660009081526001602052604090205490565b6040805160028082526060820183526000926020830190803683370190505090508360001b81600081518110610aed57610aed6124c3565b60209081029190910101528051339082906001908110610b0f57610b0f6124c3565b60209081029190910101526005541580610b2a575060055484105b610b90576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601060248201527f4d414b455f4245545445525f4d4f56450000000000000000000000000000000060448201526064016105a6565b60058490556106f53385611a65565b610baa338383611a83565b5050565b6000828152602081905260409020546affffffffffffffffffffff60a082901c167f80000000000000000000000000000000000000000000000000000000000000008083161473ffffffffffffffffffffffffffffffffffffffff8316610c44576040517f38077a2b000000000000000000000000000000000000000000000000000000008152600481018690526024016105a6565b8673ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff1614610cc9576040517f23295f0e00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8089166004830152841660248201526044016105a6565b73ffffffffffffffffffffffffffffffffffffffff86161580610d01575073ffffffffffffffffffffffffffffffffffffffff861630145b15610d50576040517f8e4c8aa600000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff871660048201526024016105a6565b3373ffffffffffffffffffffffffffffffffffffffff881614610e1257808015610d9d575060008581526003602052604090205473ffffffffffffffffffffffffffffffffffffffff1633145b158015610ddb575073ffffffffffffffffffffffffffffffffffffffff8716600090815260026020908152604080832033845290915290205460ff16155b15610e12576040517fea8e4eb500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b610e25878787601886901c151588611b1b565b50505050505050565b6040805161020081018252600281526004602082015260079181019190915260036060820152600a6080820152600960a0820152600660c0820152600060e0820181905260056101008301526001610120830152600b6101408301526008610160830152600c610180830152600d6101a0830152600e6101c0830152600f6101e08301527f0000000000000000000000000000000000000000000000000000000000000000905b83811015610fa057600082610f118582898987818110610ef757610ef76124c3565b9050602002016020810190610f0c91906124f2565b611b8e565b9450915081610f1f82611ce5565b610f2886611ce5565b610f3186611ce5565b604051602001610f439392919061252f565b60405160208183030381529060405290610f8a576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016105a691906120b6565b5050508080610f989061261e565b915050610ed5565b50817f000000000000000000000000000000000000000000000000000000000000000060108110610fd357610fd36124c3565b602002015160ff1615611042576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601960248201527f696e76616c696420736f6c7574696f6e2028636172726574290000000000000060448201526064016105a6565b60005b7f000000000000000000000000000000000000000000000000000000000000000081101561110b57611078816001612656565b83826010811061108a5761108a6124c3565b602002015160ff16146110f9576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f696e76616c696420736f6c7574696f6e20312f3200000000000000000000000060448201526064016105a6565b806111038161261e565b915050611045565b5060006111397f00000000000000000000000000000000000000000000000000000000000000006001612656565b90505b60108110156111d95780838260108110611158576111586124c3565b602002015160ff16146111c7576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f696e76616c696420736f6c7574696f6e20322f3200000000000000000000000060448201526064016105a6565b806111d18161261e565b91505061113c565b5060055415806111ea575060055483105b611250576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601060248201527f4d414b455f4245545445525f4d4f56450000000000000000000000000000000060448201526064016105a6565b60058390556106f53384611a65565b6040805160208082528183019092526060916000919060208201818036833701905050905060005b60208110156112f9578381602081106112a2576112a26124c3565b1a60f81b8282815181106112b8576112b86124c3565b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a905350806112f18161261e565b915050611287565b50604080518082018252601081527f30313233343536373839616263646566000000000000000000000000000000006020820152815182815260608101835290916000919060208201818036833701905050905060005b60208110156114e25782600485838151811061136e5761136e6124c3565b016020015182517fff0000000000000000000000000000000000000000000000000000000000000090911690911c60f81c9081106113ae576113ae6124c3565b01602001517fff0000000000000000000000000000000000000000000000000000000000000016826113e1836002612669565b815181106113f1576113f16124c3565b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a90535082848281518110611433576114336124c3565b602091010151815160f89190911c600f16908110611453576114536124c3565b01602001517fff000000000000000000000000000000000000000000000000000000000000001682611486836002612669565b611491906001612656565b815181106114a1576114a16124c3565b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a905350806114da8161261e565b915050611350565b50949350505050565b60408051808201909152601281527f566974616c696b277325323073656372657400000000000000000000000000006020820152606090808061152d85611ce5565b60405160200161153f93929190612680565b604051602081830303815290604052915050919050565b60608167ffffffffffffffff8111156115715761157161223f565b6040519080825280602002602001820160405280156115b657816020015b604080518082019091526000808252602082015281526020019060019003908161158f5790505b50905060005b828110156116865760008060008686858181106115db576115db6124c3565b90506020020135815260200190815260200160002054905080838381518110611606576116066124c3565b60200260200101516000019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff168152505060b881901c67ffffffffffffffff16838381518110611665576116656124c3565b6020908102919091018101510152508061167e8161261e565b9150506115bc565b5092915050565b611695611fd7565b61169d611fd7565b60006116ab600160106128db565b905060008282601081106116c1576116c16124c3565b60ff909216602092909202015260005b81811015611715576116e4816001612656565b8382601081106116f6576116f66124c3565b60ff90921660209290920201528061170d8161261e565b9150506116d1565b50602a60005b828110156117f057600061172f82856128db565b6040805160208101869052016040516020818303038152906040528051906020012060001c61175e919061291d565b6117689083612656565b9050600085826010811061177e5761177e6124c3565b60200201519050858360108110611797576117976124c3565b60200201518683601081106117ae576117ae6124c3565b60ff9092166020929092020152808684601081106117ce576117ce6124c3565b60ff9092166020929092020152508190506117e88161261e565b91505061171b565b50919392505050565b601883901c600061180b856001612656565b905081601882901c1461184a576040517fadc1557200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b73ffffffffffffffffffffffffffffffffffffffff841661189757600083815260208190526040902060a082901b73ffffffffffffffffffffffffffffffffffffffff881617905561191f565b60008381526020818152604080832073ffffffffffffffffffffffffffffffffffffffff8a811660a087901b177f800000000000000000000000000000000000000000000000000000000000000017909155600390925290912080547fffffffffffffffffffffffff0000000000000000000000000000000000000000169186169190911790555b828473ffffffffffffffffffffffffffffffffffffffff168773ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92560405160405180910390a4505050505050565b73ffffffffffffffffffffffffffffffffffffffff83166000908152600160208190526040909120805490910190558015611a035773ffffffffffffffffffffffffffffffffffffffff8416600090815260016020526040902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0190555b6000828152602081905260408082204360b81b73ffffffffffffffffffffffffffffffffffffffff80881691821790925591518593918816917fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef91a450505050565b610baa60008383600060405180602001604052806000815250611b1b565b73ffffffffffffffffffffffffffffffffffffffff83811660008181526002602090815260408083209487168084529482529182902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001686151590811790915591519182527f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31910160405180910390a3505050565b611b2785858585611982565b73ffffffffffffffffffffffffffffffffffffffff84163b15611b8757611b513386868685611da3565b611b87576040517f4e472e5e00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5050505050565b60008080611b9d60048661291d565b90506000611bac600487612931565b90506000856003811115611bc257611bc2612945565b03611c1157611bd3600160046128db565b821015611c0c576001935081611bea600483612669565b611bf49190612656565b611bff906001612656565b9250611c0c878785611e78565b611cdb565b6001856003811115611c2557611c25612945565b03611c6257611c36600160046128db565b811015611c0c5760019350816004611c4e8387612656565b611c589190612669565b611bff9190612656565b6002856003811115611c7657611c76612945565b03611ca6578115611c0c57600193508382611c92600484612669565b611c9c9190612656565b611bff91906128db565b6003856003811115611cba57611cba612945565b03611cd6578015611c0c5760019350816004611c4e86846128db565b600093505b5050935093915050565b60606000611cf283611ef5565b600101905060008167ffffffffffffffff811115611d1257611d1261223f565b6040519080825280601f01601f191660200182016040528015611d3c576020820181803683370190505b5090508181016020015b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff017f3031323334353637383961626364656600000000000000000000000000000000600a86061a8153600a8504945084611d4657509392505050565b6000808473ffffffffffffffffffffffffffffffffffffffff1663150b7a02888887876040518563ffffffff1660e01b8152600401611de59493929190612974565b6020604051808303816000875af1158015611e04573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611e2891906129bd565b7fffffffff00000000000000000000000000000000000000000000000000000000167f150b7a02000000000000000000000000000000000000000000000000000000001491505095945050505050565b6000838360108110611e8c57611e8c6124c3565b602002015190506000848360108110611ea757611ea76124c3565b6020020151905080858560108110611ec157611ec16124c3565b60ff909216602092909202015281858460108110611ee157611ee16124c3565b60ff90921660209290920201525050505050565b6000807a184f03e93ff9f4daa797ed6e38ed64bf6a1f0100000000000000008310611f3e577a184f03e93ff9f4daa797ed6e38ed64bf6a1f010000000000000000830492506040015b6d04ee2d6d415b85acef81000000008310611f6a576d04ee2d6d415b85acef8100000000830492506020015b662386f26fc100008310611f8857662386f26fc10000830492506010015b6305f5e1008310611fa0576305f5e100830492506008015b6127108310611fb457612710830492506004015b60648310611fc6576064830492506002015b600a83106105205760010192915050565b6040518061020001604052806010906020820280368337509192915050565b7fffffffff000000000000000000000000000000000000000000000000000000008116811461099e57600080fd5b60006020828403121561203657600080fd5b813561204181611ff6565b9392505050565b60005b8381101561206357818101518382015260200161204b565b50506000910152565b60008151808452612084816020860160208601612048565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b602081526000612041602083018461206c565b6000602082840312156120db57600080fd5b5035919050565b803573ffffffffffffffffffffffffffffffffffffffff81168114610a2057600080fd5b6000806040838503121561211957600080fd5b612122836120e2565b946020939093013593505050565b60008060006060848603121561214557600080fd5b61214e846120e2565b925061215c602085016120e2565b9150604084013590509250925092565b60006020828403121561217e57600080fd5b612041826120e2565b60008060006040848603121561219c57600080fd5b83359250602084013567ffffffffffffffff808211156121bb57600080fd5b818601915086601f8301126121cf57600080fd5b8135818111156121de57600080fd5b8760208285010111156121f057600080fd5b6020830194508093505050509250925092565b6000806040838503121561221657600080fd5b61221f836120e2565b91506020830135801515811461223457600080fd5b809150509250929050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6000806000806080858703121561228457600080fd5b61228d856120e2565b935061229b602086016120e2565b925060408501359150606085013567ffffffffffffffff808211156122bf57600080fd5b818701915087601f8301126122d357600080fd5b8135818111156122e5576122e561223f565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f0116810190838211818310171561232b5761232b61223f565b816040528281528a602084870101111561234457600080fd5b82602086016020830137600060208483010152809550505050505092959194509250565b60008083601f84011261237a57600080fd5b50813567ffffffffffffffff81111561239257600080fd5b6020830191508360208260051b85010111156123ad57600080fd5b9250929050565b600080602083850312156123c757600080fd5b823567ffffffffffffffff8111156123de57600080fd5b6123ea85828601612368565b90969095509350505050565b6000806040838503121561240957600080fd5b612412836120e2565b9150612420602084016120e2565b90509250929050565b602080825282518282018190526000919060409081850190868401855b82811015612481578151805173ffffffffffffffffffffffffffffffffffffffff168552860151868501529284019290850190600101612446565b5091979650505050505050565b6102008101818360005b60108110156124ba57815160ff16835260209283019290910190600101612498565b50505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60006020828403121561250457600080fd5b81356004811061204157600080fd5b60008151612525818560208601612048565b9290920192915050565b7f696e76616c696420000000000000000000000000000000000000000000000000815260008451612567816008850160208901612048565b7f203d3e200000000000000000000000000000000000000000000000000000000060089184019182015284516125a481600c840160208901612048565b7f203a200000000000000000000000000000000000000000000000000000000000600c929091019182015283516125e281600f840160208801612048565b01600f0195945050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff820361264f5761264f6125ef565b5060010190565b80820180821115610520576105206125ef565b8082028115828204841417610520576105206125ef565b7f646174613a6170706c69636174696f6e2f6a736f6e2c7b226e616d65223a22008152600084516126b881601f850160208901612048565b7f222c226465736372697074696f6e223a22000000000000000000000000000000601f9184019182015284516126f5816030840160208901612048565b7f222c22696d616765223a22000000000000000000000000000000000000000000603092909101918201527f646174613a696d6167652f7376672b786d6c2c3c737667253235323076696577603b8201527f426f783d27302532353230302532353230333225323532303136272532353230605b8201527f786d6c6e733d27687474703a2f2f7777772e77332e6f72672f323030302f7376607b8201527f67273e3c746578742532353230783d27353025272532353230793d2735302527609b8201527f2532353230646f6d696e616e742d626173656c696e653d276d6964646c65272560bb8201527f32353230746578742d616e63686f723d276d6964646c6527253235323073747960db8201527f6c653d2766696c6c3a726762283231392c33392c313139293b666f6e742d736960fb8201527f7a653a3270783b273e000000000000000000000000000000000000000000000061011b82015261285f610124820185612513565b7f253230000000000000000000000000000000000000000000000000000000000081527f6d6f76657300000000000000000000000000000000000000000000000000000060038201527f3c2f746578743e3c2f7376673e227d000000000000000000000000000000000060088201526017019695505050505050565b81810381811115610520576105206125ef565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b60008261292c5761292c6128ee565b500690565b600082612940576129406128ee565b500490565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b600073ffffffffffffffffffffffffffffffffffffffff8087168352808616602084015250836040830152608060608301526129b3608083018461206c565b9695505050505050565b6000602082840312156129cf57600080fd5b815161204181611ff656fea264697066735822122044fd203d8a48c579365d9a5e6523c3f0258852ed8f8cd11381a76a12110a1baa64736f6c63430008140033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106101825760003560e01c80639e06c90b116100d8578063c68b37871161008c578063f394528211610066578063f394528214610403578063f66168c814610423578063fd82234c1461043857600080fd5b8063c68b378714610394578063c87b56dd146103a7578063e985e9c5146103ba57600080fd5b8063b88d4fde116100bd578063b88d4fde14610366578063bdffd28214610379578063c370c3c71461038157600080fd5b80639e06c90b14610340578063a22cb4651461035357600080fd5b80632f3f94ae1161013a5780636352211e116101145780636352211e146102d357806370a08231146102e657806395d89b411461030757600080fd5b80632f3f94ae1461025157806342842e0e1461026457806348f3c51c1461027757600080fd5b8063081812fc1161016b578063081812fc146101f1578063095ea7b31461022957806323b872dd1461023e57600080fd5b806301ffc9a71461018757806306fdde03146101af575b600080fd5b61019a610195366004612024565b610441565b60405190151581526020015b60405180910390f35b60408051808201909152600e81527f564954414c494b2053454352455400000000000000000000000000000000000060208201525b6040516101a691906120b6565b6102046101ff3660046120c9565b610526565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020016101a6565b61023c610237366004612106565b6105ea565b005b61023c61024c366004612130565b6106fb565b61023c61025f3660046120c9565b610979565b61023c610272366004612130565b6109a1565b6102a76102853660046120c9565b6000908152602081905260409020549067ffffffffffffffff60b883901c1690565b6040805173ffffffffffffffffffffffffffffffffffffffff90931683526020830191909152016101a6565b6102046102e13660046120c9565b6109c1565b6102f96102f436600461216c565b610a25565b6040519081526020016101a6565b60408051808201909152600381527f565453000000000000000000000000000000000000000000000000000000000060208201526101e4565b61023c61034e366004612187565b610ab5565b61023c610361366004612203565b610b9f565b61023c61037436600461226e565b610bae565b6102f9600481565b61023c61038f3660046123b4565b610e2e565b6101e46103a23660046120c9565b61125f565b6101e46103b53660046120c9565b6114eb565b61019a6103c83660046123f6565b73ffffffffffffffffffffffffffffffffffffffff918216600090815260026020908152604080832093909416825291909152205460ff1690565b6104166104113660046123b4565b611556565b6040516101a69190612429565b61042b61168d565b6040516101a6919061248e565b6102f960055481565b60007f01ffc9a7000000000000000000000000000000000000000000000000000000007fffffffff00000000000000000000000000000000000000000000000000000000831614806104d457507f80ac58cd000000000000000000000000000000000000000000000000000000007fffffffff000000000000000000000000000000000000000000000000000000008316145b8061052057507f5b5e139f000000000000000000000000000000000000000000000000000000007fffffffff000000000000000000000000000000000000000000000000000000008316145b92915050565b6000818152602081905260408120547f80000000000000000000000000000000000000000000000000000000000000008082161473ffffffffffffffffffffffffffffffffffffffff82166105af576040517f38077a2b000000000000000000000000000000000000000000000000000000008152600481018590526024015b60405180910390fd5b80156105e05750505060009081526003602052604090205473ffffffffffffffffffffffffffffffffffffffff1690565b5060009392505050565b6000818152602081905260409020546affffffffffffffffffffff60a082901c1673ffffffffffffffffffffffffffffffffffffffff821661065b576040517f38077a2b000000000000000000000000000000000000000000000000000000008152600481018490526024016105a6565b3373ffffffffffffffffffffffffffffffffffffffff8316148015906106b2575073ffffffffffffffffffffffffffffffffffffffff8216600090815260026020908152604080832033845290915290205460ff16155b156106e9576040517fea8e4eb500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6106f5828286866117f9565b50505050565b6000818152602081905260409020546affffffffffffffffffffff60a082901c167f80000000000000000000000000000000000000000000000000000000000000008083161473ffffffffffffffffffffffffffffffffffffffff8316610791576040517f38077a2b000000000000000000000000000000000000000000000000000000008152600481018590526024016105a6565b8273ffffffffffffffffffffffffffffffffffffffff168673ffffffffffffffffffffffffffffffffffffffff1614610816576040517f23295f0e00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8088166004830152841660248201526044016105a6565b73ffffffffffffffffffffffffffffffffffffffff8516158061084e575073ffffffffffffffffffffffffffffffffffffffff851630145b1561089d576040517f8e4c8aa600000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff861660048201526024016105a6565b3373ffffffffffffffffffffffffffffffffffffffff87161461095f578080156108ea575060008481526003602052604090205473ffffffffffffffffffffffffffffffffffffffff1633145b158015610928575073ffffffffffffffffffffffffffffffffffffffff8616600090815260026020908152604080832033845290915290205460ff16155b1561095f576040517fea8e4eb500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b610971868686601886901c1515611982565b505050505050565b6005541580610989575060055481105b156109945760058190555b61099e3382611a65565b50565b6109bc83838360405180602001604052806000815250610bae565b505050565b60008181526020819052604090205473ffffffffffffffffffffffffffffffffffffffff8116610a20576040517f38077a2b000000000000000000000000000000000000000000000000000000008152600481018390526024016105a6565b919050565b600073ffffffffffffffffffffffffffffffffffffffff8216610a8c576040517f8e4c8aa600000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff831660048201526024016105a6565b5073ffffffffffffffffffffffffffffffffffffffff1660009081526001602052604090205490565b6040805160028082526060820183526000926020830190803683370190505090508360001b81600081518110610aed57610aed6124c3565b60209081029190910101528051339082906001908110610b0f57610b0f6124c3565b60209081029190910101526005541580610b2a575060055484105b610b90576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601060248201527f4d414b455f4245545445525f4d4f56450000000000000000000000000000000060448201526064016105a6565b60058490556106f53385611a65565b610baa338383611a83565b5050565b6000828152602081905260409020546affffffffffffffffffffff60a082901c167f80000000000000000000000000000000000000000000000000000000000000008083161473ffffffffffffffffffffffffffffffffffffffff8316610c44576040517f38077a2b000000000000000000000000000000000000000000000000000000008152600481018690526024016105a6565b8673ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff1614610cc9576040517f23295f0e00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8089166004830152841660248201526044016105a6565b73ffffffffffffffffffffffffffffffffffffffff86161580610d01575073ffffffffffffffffffffffffffffffffffffffff861630145b15610d50576040517f8e4c8aa600000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff871660048201526024016105a6565b3373ffffffffffffffffffffffffffffffffffffffff881614610e1257808015610d9d575060008581526003602052604090205473ffffffffffffffffffffffffffffffffffffffff1633145b158015610ddb575073ffffffffffffffffffffffffffffffffffffffff8716600090815260026020908152604080832033845290915290205460ff16155b15610e12576040517fea8e4eb500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b610e25878787601886901c151588611b1b565b50505050505050565b6040805161020081018252600281526004602082015260079181019190915260036060820152600a6080820152600960a0820152600660c0820152600060e0820181905260056101008301526001610120830152600b6101408301526008610160830152600c610180830152600d6101a0830152600e6101c0830152600f6101e08301527f0000000000000000000000000000000000000000000000000000000000000000905b83811015610fa057600082610f118582898987818110610ef757610ef76124c3565b9050602002016020810190610f0c91906124f2565b611b8e565b9450915081610f1f82611ce5565b610f2886611ce5565b610f3186611ce5565b604051602001610f439392919061252f565b60405160208183030381529060405290610f8a576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016105a691906120b6565b5050508080610f989061261e565b915050610ed5565b50817f000000000000000000000000000000000000000000000000000000000000000060108110610fd357610fd36124c3565b602002015160ff1615611042576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601960248201527f696e76616c696420736f6c7574696f6e2028636172726574290000000000000060448201526064016105a6565b60005b7f000000000000000000000000000000000000000000000000000000000000000081101561110b57611078816001612656565b83826010811061108a5761108a6124c3565b602002015160ff16146110f9576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f696e76616c696420736f6c7574696f6e20312f3200000000000000000000000060448201526064016105a6565b806111038161261e565b915050611045565b5060006111397f00000000000000000000000000000000000000000000000000000000000000006001612656565b90505b60108110156111d95780838260108110611158576111586124c3565b602002015160ff16146111c7576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f696e76616c696420736f6c7574696f6e20322f3200000000000000000000000060448201526064016105a6565b806111d18161261e565b91505061113c565b5060055415806111ea575060055483105b611250576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601060248201527f4d414b455f4245545445525f4d4f56450000000000000000000000000000000060448201526064016105a6565b60058390556106f53384611a65565b6040805160208082528183019092526060916000919060208201818036833701905050905060005b60208110156112f9578381602081106112a2576112a26124c3565b1a60f81b8282815181106112b8576112b86124c3565b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a905350806112f18161261e565b915050611287565b50604080518082018252601081527f30313233343536373839616263646566000000000000000000000000000000006020820152815182815260608101835290916000919060208201818036833701905050905060005b60208110156114e25782600485838151811061136e5761136e6124c3565b016020015182517fff0000000000000000000000000000000000000000000000000000000000000090911690911c60f81c9081106113ae576113ae6124c3565b01602001517fff0000000000000000000000000000000000000000000000000000000000000016826113e1836002612669565b815181106113f1576113f16124c3565b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a90535082848281518110611433576114336124c3565b602091010151815160f89190911c600f16908110611453576114536124c3565b01602001517fff000000000000000000000000000000000000000000000000000000000000001682611486836002612669565b611491906001612656565b815181106114a1576114a16124c3565b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a905350806114da8161261e565b915050611350565b50949350505050565b60408051808201909152601281527f566974616c696b277325323073656372657400000000000000000000000000006020820152606090808061152d85611ce5565b60405160200161153f93929190612680565b604051602081830303815290604052915050919050565b60608167ffffffffffffffff8111156115715761157161223f565b6040519080825280602002602001820160405280156115b657816020015b604080518082019091526000808252602082015281526020019060019003908161158f5790505b50905060005b828110156116865760008060008686858181106115db576115db6124c3565b90506020020135815260200190815260200160002054905080838381518110611606576116066124c3565b60200260200101516000019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff168152505060b881901c67ffffffffffffffff16838381518110611665576116656124c3565b6020908102919091018101510152508061167e8161261e565b9150506115bc565b5092915050565b611695611fd7565b61169d611fd7565b60006116ab600160106128db565b905060008282601081106116c1576116c16124c3565b60ff909216602092909202015260005b81811015611715576116e4816001612656565b8382601081106116f6576116f66124c3565b60ff90921660209290920201528061170d8161261e565b9150506116d1565b50602a60005b828110156117f057600061172f82856128db565b6040805160208101869052016040516020818303038152906040528051906020012060001c61175e919061291d565b6117689083612656565b9050600085826010811061177e5761177e6124c3565b60200201519050858360108110611797576117976124c3565b60200201518683601081106117ae576117ae6124c3565b60ff9092166020929092020152808684601081106117ce576117ce6124c3565b60ff9092166020929092020152508190506117e88161261e565b91505061171b565b50919392505050565b601883901c600061180b856001612656565b905081601882901c1461184a576040517fadc1557200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b73ffffffffffffffffffffffffffffffffffffffff841661189757600083815260208190526040902060a082901b73ffffffffffffffffffffffffffffffffffffffff881617905561191f565b60008381526020818152604080832073ffffffffffffffffffffffffffffffffffffffff8a811660a087901b177f800000000000000000000000000000000000000000000000000000000000000017909155600390925290912080547fffffffffffffffffffffffff0000000000000000000000000000000000000000169186169190911790555b828473ffffffffffffffffffffffffffffffffffffffff168773ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92560405160405180910390a4505050505050565b73ffffffffffffffffffffffffffffffffffffffff83166000908152600160208190526040909120805490910190558015611a035773ffffffffffffffffffffffffffffffffffffffff8416600090815260016020526040902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0190555b6000828152602081905260408082204360b81b73ffffffffffffffffffffffffffffffffffffffff80881691821790925591518593918816917fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef91a450505050565b610baa60008383600060405180602001604052806000815250611b1b565b73ffffffffffffffffffffffffffffffffffffffff83811660008181526002602090815260408083209487168084529482529182902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001686151590811790915591519182527f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31910160405180910390a3505050565b611b2785858585611982565b73ffffffffffffffffffffffffffffffffffffffff84163b15611b8757611b513386868685611da3565b611b87576040517f4e472e5e00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5050505050565b60008080611b9d60048661291d565b90506000611bac600487612931565b90506000856003811115611bc257611bc2612945565b03611c1157611bd3600160046128db565b821015611c0c576001935081611bea600483612669565b611bf49190612656565b611bff906001612656565b9250611c0c878785611e78565b611cdb565b6001856003811115611c2557611c25612945565b03611c6257611c36600160046128db565b811015611c0c5760019350816004611c4e8387612656565b611c589190612669565b611bff9190612656565b6002856003811115611c7657611c76612945565b03611ca6578115611c0c57600193508382611c92600484612669565b611c9c9190612656565b611bff91906128db565b6003856003811115611cba57611cba612945565b03611cd6578015611c0c5760019350816004611c4e86846128db565b600093505b5050935093915050565b60606000611cf283611ef5565b600101905060008167ffffffffffffffff811115611d1257611d1261223f565b6040519080825280601f01601f191660200182016040528015611d3c576020820181803683370190505b5090508181016020015b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff017f3031323334353637383961626364656600000000000000000000000000000000600a86061a8153600a8504945084611d4657509392505050565b6000808473ffffffffffffffffffffffffffffffffffffffff1663150b7a02888887876040518563ffffffff1660e01b8152600401611de59493929190612974565b6020604051808303816000875af1158015611e04573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611e2891906129bd565b7fffffffff00000000000000000000000000000000000000000000000000000000167f150b7a02000000000000000000000000000000000000000000000000000000001491505095945050505050565b6000838360108110611e8c57611e8c6124c3565b602002015190506000848360108110611ea757611ea76124c3565b6020020151905080858560108110611ec157611ec16124c3565b60ff909216602092909202015281858460108110611ee157611ee16124c3565b60ff90921660209290920201525050505050565b6000807a184f03e93ff9f4daa797ed6e38ed64bf6a1f0100000000000000008310611f3e577a184f03e93ff9f4daa797ed6e38ed64bf6a1f010000000000000000830492506040015b6d04ee2d6d415b85acef81000000008310611f6a576d04ee2d6d415b85acef8100000000830492506020015b662386f26fc100008310611f8857662386f26fc10000830492506010015b6305f5e1008310611fa0576305f5e100830492506008015b6127108310611fb457612710830492506004015b60648310611fc6576064830492506002015b600a83106105205760010192915050565b6040518061020001604052806010906020820280368337509192915050565b7fffffffff000000000000000000000000000000000000000000000000000000008116811461099e57600080fd5b60006020828403121561203657600080fd5b813561204181611ff6565b9392505050565b60005b8381101561206357818101518382015260200161204b565b50506000910152565b60008151808452612084816020860160208601612048565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b602081526000612041602083018461206c565b6000602082840312156120db57600080fd5b5035919050565b803573ffffffffffffffffffffffffffffffffffffffff81168114610a2057600080fd5b6000806040838503121561211957600080fd5b612122836120e2565b946020939093013593505050565b60008060006060848603121561214557600080fd5b61214e846120e2565b925061215c602085016120e2565b9150604084013590509250925092565b60006020828403121561217e57600080fd5b612041826120e2565b60008060006040848603121561219c57600080fd5b83359250602084013567ffffffffffffffff808211156121bb57600080fd5b818601915086601f8301126121cf57600080fd5b8135818111156121de57600080fd5b8760208285010111156121f057600080fd5b6020830194508093505050509250925092565b6000806040838503121561221657600080fd5b61221f836120e2565b91506020830135801515811461223457600080fd5b809150509250929050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6000806000806080858703121561228457600080fd5b61228d856120e2565b935061229b602086016120e2565b925060408501359150606085013567ffffffffffffffff808211156122bf57600080fd5b818701915087601f8301126122d357600080fd5b8135818111156122e5576122e561223f565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f0116810190838211818310171561232b5761232b61223f565b816040528281528a602084870101111561234457600080fd5b82602086016020830137600060208483010152809550505050505092959194509250565b60008083601f84011261237a57600080fd5b50813567ffffffffffffffff81111561239257600080fd5b6020830191508360208260051b85010111156123ad57600080fd5b9250929050565b600080602083850312156123c757600080fd5b823567ffffffffffffffff8111156123de57600080fd5b6123ea85828601612368565b90969095509350505050565b6000806040838503121561240957600080fd5b612412836120e2565b9150612420602084016120e2565b90509250929050565b602080825282518282018190526000919060409081850190868401855b82811015612481578151805173ffffffffffffffffffffffffffffffffffffffff168552860151868501529284019290850190600101612446565b5091979650505050505050565b6102008101818360005b60108110156124ba57815160ff16835260209283019290910190600101612498565b50505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60006020828403121561250457600080fd5b81356004811061204157600080fd5b60008151612525818560208601612048565b9290920192915050565b7f696e76616c696420000000000000000000000000000000000000000000000000815260008451612567816008850160208901612048565b7f203d3e200000000000000000000000000000000000000000000000000000000060089184019182015284516125a481600c840160208901612048565b7f203a200000000000000000000000000000000000000000000000000000000000600c929091019182015283516125e281600f840160208801612048565b01600f0195945050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff820361264f5761264f6125ef565b5060010190565b80820180821115610520576105206125ef565b8082028115828204841417610520576105206125ef565b7f646174613a6170706c69636174696f6e2f6a736f6e2c7b226e616d65223a22008152600084516126b881601f850160208901612048565b7f222c226465736372697074696f6e223a22000000000000000000000000000000601f9184019182015284516126f5816030840160208901612048565b7f222c22696d616765223a22000000000000000000000000000000000000000000603092909101918201527f646174613a696d6167652f7376672b786d6c2c3c737667253235323076696577603b8201527f426f783d27302532353230302532353230333225323532303136272532353230605b8201527f786d6c6e733d27687474703a2f2f7777772e77332e6f72672f323030302f7376607b8201527f67273e3c746578742532353230783d27353025272532353230793d2735302527609b8201527f2532353230646f6d696e616e742d626173656c696e653d276d6964646c65272560bb8201527f32353230746578742d616e63686f723d276d6964646c6527253235323073747960db8201527f6c653d2766696c6c3a726762283231392c33392c313139293b666f6e742d736960fb8201527f7a653a3270783b273e000000000000000000000000000000000000000000000061011b82015261285f610124820185612513565b7f253230000000000000000000000000000000000000000000000000000000000081527f6d6f76657300000000000000000000000000000000000000000000000000000060038201527f3c2f746578743e3c2f7376673e227d000000000000000000000000000000000060088201526017019695505050505050565b81810381811115610520576105206125ef565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b60008261292c5761292c6128ee565b500690565b600082612940576129406128ee565b500490565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b600073ffffffffffffffffffffffffffffffffffffffff8087168352808616602084015250836040830152608060608301526129b3608083018461206c565b9695505050505050565b6000602082840312156129cf57600080fd5b815161204181611ff656fea264697066735822122044fd203d8a48c579365d9a5e6523c3f0258852ed8f8cd11381a76a12110a1baa64736f6c63430008140033",
  "linkReferences": {},
  "deployedLinkReferences": {},
  "devdoc": {
    "errors": {
      "InvalidAddress(address)": [
        {
          "params": {
            "addr": "invalid address"
          }
        }
      ],
      "NonExistentToken(uint256)": [
        {
          "params": {
            "tokenID": "id of the expected token"
          }
        }
      ],
      "NotOwner(address,address)": [
        {
          "params": {
            "currentOwner": "the current owner",
            "provided": "the address expected to be the current owner"
          }
        }
      ]
    },
    "events": {
      "Approval(address,address,uint256)": {
        "params": {
          "approved": "account who can know transfer on the owner's behalf",
          "owner": "current owner of the token",
          "tokenID": "id of the token being approved"
        }
      },
      "ApprovalForAll(address,address,bool)": {
        "params": {
          "approved": "whether it is approved or not",
          "operator": "account who can know transfer on the owner's behalf",
          "owner": "the account granting rights over all of its token"
        }
      },
      "Transfer(address,address,uint256)": {
        "params": {
          "from": "the account the token is sent from",
          "to": "the account the token is sent to",
          "tokenID": "id of the token being sent"
        }
      }
    },
    "kind": "dev",
    "methods": {
      "approve(address,uint256)": {
        "params": {
          "operator": "The address receiving the approval.",
          "tokenID": "The id of the token."
        }
      },
      "balanceOf(address)": {
        "params": {
          "owner": "The address to look for."
        },
        "returns": {
          "balance": "The number of tokens owned by the address."
        }
      },
      "getApproved(uint256)": {
        "params": {
          "tokenID": "The id of the token."
        },
        "returns": {
          "operator": "The address of the operator."
        }
      },
      "isApprovedForAll(address,address)": {
        "params": {
          "operator": "The address of the operator.",
          "owner": "The address of the owner."
        },
        "returns": {
          "isOperator": "The status of the approval."
        }
      },
      "ownerAndLastTransferBlockNumberList(uint256[])": {
        "params": {
          "tokenIDs": "The list of token ids to check."
        },
        "returns": {
          "ownersData": "The list of (owner, lastTransferBlockNumber) for each ids given as input."
        }
      },
      "ownerAndLastTransferBlockNumberOf(uint256)": {
        "params": {
          "tokenID": "The id of the token."
        },
        "returns": {
          "blockNumber": "The blocknumber at which the last transfer of that id happened.",
          "owner": "The address of the token owner."
        }
      },
      "ownerOf(uint256)": {
        "params": {
          "tokenID": "The id of the token."
        },
        "returns": {
          "owner": "The address of the token owner."
        }
      },
      "safeTransferFrom(address,address,uint256)": {
        "params": {
          "from": "The send of the token.",
          "to": "The recipient of the token.",
          "tokenID": "The id of the token."
        }
      },
      "safeTransferFrom(address,address,uint256,bytes)": {
        "params": {
          "data": "Additional data.",
          "from": "The sender of the token.",
          "to": "The recipient of the token.",
          "tokenID": "The id of the token."
        }
      },
      "setApprovalForAll(address,bool)": {
        "params": {
          "approved": "The determination of the approval.",
          "operator": "The address receiving the approval."
        }
      },
      "supportsInterface(bytes4)": {
        "details": "Interface identification is specified in ERC-165. This function  uses less than 30,000 gas.",
        "params": {
          "interfaceID": "The interface identifier, as specified in ERC-165"
        },
        "returns": {
          "_0": "`true` if the contract implements `interfaceID` and  `interfaceID` is not 0xffffffff, `false` otherwise"
        }
      },
      "tokenURI(uint256)": {
        "details": "Throws if `tokenID` is not a valid NFT. URIs are defined in RFC  3986. The URI may point to a JSON file that conforms to the \"ERC721  Metadata JSON Schema\".",
        "params": {
          "tokenID": "id of the token being queried."
        }
      },
      "transferFrom(address,address,uint256)": {
        "params": {
          "from": "The sender of the token.",
          "to": "The recipient of the token.",
          "tokenID": "The id of the token."
        }
      }
    },
    "version": 1
  },
  "evm": {
    "gasEstimates": {
      "creation": {
        "codeDepositCost": "2153600",
        "executionCost": "infinite",
        "totalCost": "infinite"
      },
      "external": {
        "SIZE()": "262",
        "approve(address,uint256)": "53543",
        "balanceOf(address)": "2620",
        "bytes32ToHexString(bytes32)": "infinite",
        "getApproved(uint256)": "4746",
        "isApprovedForAll(address,address)": "infinite",
        "lowestNumberOfMoves()": "2383",
        "name()": "infinite",
        "ownerAndLastTransferBlockNumberList(uint256[])": "infinite",
        "ownerAndLastTransferBlockNumberOf(uint256)": "2585",
        "ownerOf(uint256)": "2535",
        "proposeSolution(uint8[])": "infinite",
        "proposeSolutionProof(uint256,bytes)": "infinite",
        "randomState()": "infinite",
        "safeTransferFrom(address,address,uint256)": "infinite",
        "safeTransferFrom(address,address,uint256,bytes)": "infinite",
        "setApprovalForAll(address,bool)": "26665",
        "supportsInterface(bytes4)": "479",
        "symbol()": "infinite",
        "testMint(uint256)": "infinite",
        "tokenURI(uint256)": "infinite",
        "transferFrom(address,address,uint256)": "infinite"
      },
      "internal": {
        "_swap(uint8[16] memory,uint256,uint256)": "infinite",
        "randomSeed()": "infinite",
        "step(uint8[16] memory,uint256,enum VitalikSecret.Move)": "infinite"
      }
    }
  },
  "metadata": "{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"InvalidAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"NonExistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NonceOverflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotAuthorized\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"provided\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currentOwner\",\"type\":\"address\"}],\"name\":\"NotOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferRejected\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"SIZE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_bytes32\",\"type\":\"bytes32\"}],\"name\":\"bytes32ToHexString\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isOperator\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lowestNumberOfMoves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIDs\",\"type\":\"uint256[]\"}],\"name\":\"ownerAndLastTransferBlockNumberList\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lastTransferBlockNumber\",\"type\":\"uint256\"}],\"internalType\":\"struct IERC721WithBlocknumber.OwnerData[]\",\"name\":\"ownersData\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"ownerAndLastTransferBlockNumberOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum VitalikSecret.Move[]\",\"name\":\"moves\",\"type\":\"uint8[]\"}],\"name\":\"proposeSolution\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numMoves\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"proof\",\"type\":\"bytes\"}],\"name\":\"proposeSolutionProof\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"randomState\",\"outputs\":[{\"internalType\":\"uint8[16]\",\"name\":\"\",\"type\":\"uint8[16]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numMoves\",\"type\":\"uint256\"}],\"name\":\"testMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"InvalidAddress(address)\":[{\"params\":{\"addr\":\"invalid address\"}}],\"NonExistentToken(uint256)\":[{\"params\":{\"tokenID\":\"id of the expected token\"}}],\"NotOwner(address,address)\":[{\"params\":{\"currentOwner\":\"the current owner\",\"provided\":\"the address expected to be the current owner\"}}]},\"events\":{\"Approval(address,address,uint256)\":{\"params\":{\"approved\":\"account who can know transfer on the owner's behalf\",\"owner\":\"current owner of the token\",\"tokenID\":\"id of the token being approved\"}},\"ApprovalForAll(address,address,bool)\":{\"params\":{\"approved\":\"whether it is approved or not\",\"operator\":\"account who can know transfer on the owner's behalf\",\"owner\":\"the account granting rights over all of its token\"}},\"Transfer(address,address,uint256)\":{\"params\":{\"from\":\"the account the token is sent from\",\"to\":\"the account the token is sent to\",\"tokenID\":\"id of the token being sent\"}}},\"kind\":\"dev\",\"methods\":{\"approve(address,uint256)\":{\"params\":{\"operator\":\"The address receiving the approval.\",\"tokenID\":\"The id of the token.\"}},\"balanceOf(address)\":{\"params\":{\"owner\":\"The address to look for.\"},\"returns\":{\"balance\":\"The number of tokens owned by the address.\"}},\"getApproved(uint256)\":{\"params\":{\"tokenID\":\"The id of the token.\"},\"returns\":{\"operator\":\"The address of the operator.\"}},\"isApprovedForAll(address,address)\":{\"params\":{\"operator\":\"The address of the operator.\",\"owner\":\"The address of the owner.\"},\"returns\":{\"isOperator\":\"The status of the approval.\"}},\"ownerAndLastTransferBlockNumberList(uint256[])\":{\"params\":{\"tokenIDs\":\"The list of token ids to check.\"},\"returns\":{\"ownersData\":\"The list of (owner, lastTransferBlockNumber) for each ids given as input.\"}},\"ownerAndLastTransferBlockNumberOf(uint256)\":{\"params\":{\"tokenID\":\"The id of the token.\"},\"returns\":{\"blockNumber\":\"The blocknumber at which the last transfer of that id happened.\",\"owner\":\"The address of the token owner.\"}},\"ownerOf(uint256)\":{\"params\":{\"tokenID\":\"The id of the token.\"},\"returns\":{\"owner\":\"The address of the token owner.\"}},\"safeTransferFrom(address,address,uint256)\":{\"params\":{\"from\":\"The send of the token.\",\"to\":\"The recipient of the token.\",\"tokenID\":\"The id of the token.\"}},\"safeTransferFrom(address,address,uint256,bytes)\":{\"params\":{\"data\":\"Additional data.\",\"from\":\"The sender of the token.\",\"to\":\"The recipient of the token.\",\"tokenID\":\"The id of the token.\"}},\"setApprovalForAll(address,bool)\":{\"params\":{\"approved\":\"The determination of the approval.\",\"operator\":\"The address receiving the approval.\"}},\"supportsInterface(bytes4)\":{\"details\":\"Interface identification is specified in ERC-165. This function  uses less than 30,000 gas.\",\"params\":{\"interfaceID\":\"The interface identifier, as specified in ERC-165\"},\"returns\":{\"_0\":\"`true` if the contract implements `interfaceID` and  `interfaceID` is not 0xffffffff, `false` otherwise\"}},\"tokenURI(uint256)\":{\"details\":\"Throws if `tokenID` is not a valid NFT. URIs are defined in RFC  3986. The URI may point to a JSON file that conforms to the \\\"ERC721  Metadata JSON Schema\\\".\",\"params\":{\"tokenID\":\"id of the token being queried.\"}},\"transferFrom(address,address,uint256)\":{\"params\":{\"from\":\"The sender of the token.\",\"to\":\"The recipient of the token.\",\"tokenID\":\"The id of the token.\"}}},\"version\":1},\"userdoc\":{\"errors\":{\"InvalidAddress(address)\":[{\"notice\":\"An invalid address is specified (for example: zero address)\"}],\"NonExistentToken(uint256)\":[{\"notice\":\"The token does not exist\"}],\"NonceOverflow()\":[{\"notice\":\"The Nonce overflowed, make a transfer to self to allow new nonces.\"}],\"NotAuthorized()\":[{\"notice\":\"Not authorized to perform this operation\"}],\"NotOwner(address,address)\":[{\"notice\":\"The address from which the token is sent is not the current owner\"}],\"TransferRejected()\":[{\"notice\":\"The Transfer was rejected by the destination\"}]},\"events\":{\"Approval(address,address,uint256)\":{\"notice\":\"Triggered when a token is approved to be sent by another account  Note tat the approval get reset when a Transfer event for that same token is emitted.\"},\"ApprovalForAll(address,address,bool)\":{\"notice\":\"Triggered when an account approve or disaprove another to transfer on its behalf\"},\"Transfer(address,address,uint256)\":{\"notice\":\"Triggered when a token is transferred\"}},\"kind\":\"user\",\"methods\":{\"approve(address,uint256)\":{\"notice\":\"Approve an operator to transfer a specific token on the senders behalf.\"},\"balanceOf(address)\":{\"notice\":\"Get the number of tokens owned by an address.\"},\"getApproved(uint256)\":{\"notice\":\"Get the approved operator for a specific token.\"},\"isApprovedForAll(address,address)\":{\"notice\":\"Check if the sender approved the operator to transfer any of its tokens.\"},\"name()\":{\"notice\":\"A descriptive name for a collection of NFTs in this contract\"},\"ownerAndLastTransferBlockNumberList(uint256[])\":{\"notice\":\"Get the list of owner of a token and the blockNumber of its last transfer, useful to voting mechanism.\"},\"ownerAndLastTransferBlockNumberOf(uint256)\":{\"notice\":\"Get the owner of a token and the blockNumber of the last transfer, useful to voting mechanism.\"},\"ownerOf(uint256)\":{\"notice\":\"Get the owner of a token.\"},\"safeTransferFrom(address,address,uint256)\":{\"notice\":\"Transfer a token between 2 addresses letting the receiver know of the transfer.\"},\"safeTransferFrom(address,address,uint256,bytes)\":{\"notice\":\"Transfer a token between 2 addresses letting the receiver knows of the transfer.\"},\"setApprovalForAll(address,bool)\":{\"notice\":\"Set the approval for an operator to manage all the tokens of the sender.\"},\"supportsInterface(bytes4)\":{\"notice\":\"Query if a contract implements an interface\"},\"symbol()\":{\"notice\":\"An abbreviated name for NFTs in this contract\"},\"tokenURI(uint256)\":{\"notice\":\"A distinct Uniform Resource Identifier (URI) for a given asset.\"},\"transferFrom(address,address,uint256)\":{\"notice\":\"Transfer a token between 2 addresses.\"}},\"notice\":\"a puzzle\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/VitalikSecret.sol\":\"VitalikSecret\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":999999},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Math} from \\\"./math/Math.sol\\\";\\nimport {SignedMath} from \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant HEX_DIGITS = \\\"0123456789abcdef\\\";\\n    uint8 private constant ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev The `value` string doesn't fit in the specified `length`.\\n     */\\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toStringSigned(int256 value) internal pure returns (string memory) {\\n        return string.concat(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value)));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        uint256 localValue = value;\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\\n            localValue >>= 4;\\n        }\\n        if (localValue != 0) {\\n            revert StringsInsufficientHexLength(value, length);\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\\n     * representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\",\"keccak256\":\"0x55f102ea785d8399c0e58d1108e2d289506dde18abc6db1b7f68c1f9f9bc5792\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Muldiv operation overflow.\\n     */\\n    error MathOverflowedMulDiv();\\n\\n    enum Rounding {\\n        Floor, // Toward negative infinity\\n        Ceil, // Toward positive infinity\\n        Trunc, // Toward zero\\n        Expand // Away from zero\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds towards infinity instead\\n     * of rounding towards zero.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (b == 0) {\\n            // Guarantee the same behavior as in a regular Solidity division.\\n            return a / b;\\n        }\\n\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\\n     * denominator == 0.\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\\n     * Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            if (denominator <= prod1) {\\n                revert MathOverflowedMulDiv();\\n            }\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\\n\\n            uint256 twos = denominator & (0 - denominator);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\\n            // works in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\\n     * towards zero.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\\n     */\\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\\n        return uint8(rounding) % 2 == 1;\\n    }\\n}\\n\",\"keccak256\":\"0x005ec64c6313f0555d59e278f9a7a5ab2db5bdc72a027f255a37c327af1ec02d\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SignedMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x5f7e4076e175393767754387c962926577f1660dd9b810187b9002407656be72\",\"license\":\"MIT\"},\"solidity-kit/solc_0.8/ERC165/interfaces/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IERC165 {\\n    /// @notice Query if a contract implements an interface\\n    /// @param interfaceID The interface identifier, as specified in ERC-165\\n    /// @dev Interface identification is specified in ERC-165. This function\\n    ///  uses less than 30,000 gas.\\n    /// @return `true` if the contract implements `interfaceID` and\\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x0bbdb7cf3d2c6acf95398c0ef54cb0e6ae8a3e6ce6f18fafeb0aa55cb74fb8fd\",\"license\":\"MIT\"},\"solidity-kit/solc_0.8/ERC721/implementations/BasicERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/IERC721Receiver.sol\\\";\\nimport \\\"../interfaces/IERC721.sol\\\";\\nimport \\\"../interfaces/IERC721WithBlocknumber.sol\\\";\\nimport \\\"./ImplementingERC721Internal.sol\\\";\\n\\nimport \\\"../../openzeppelin/contracts/utils/Address.sol\\\";\\n\\nabstract contract BasicERC721 is IERC721, IERC721WithBlocknumber, ImplementingERC721Internal {\\n    using Openzeppelin_Address for address;\\n\\n    bytes4 internal constant ERC721_RECEIVED = 0x150b7a02;\\n\\n    uint256 internal constant OPERATOR_FLAG = 0x8000000000000000000000000000000000000000000000000000000000000000;\\n\\n    mapping(uint256 => uint256) internal _owners;\\n    mapping(address => uint256) internal _balances;\\n    mapping(address => mapping(address => bool)) internal _operatorsForAll;\\n    mapping(uint256 => address) internal _operators;\\n\\n    /// @inheritdoc IERC721\\n    function approve(address operator, uint256 tokenID) external override {\\n        (address owner, uint256 nonce) = _ownerAndNonceOf(tokenID);\\n        if (owner == address(0)) {\\n            revert NonExistentToken(tokenID);\\n        }\\n        if (msg.sender != owner && !isApprovedForAll(owner, msg.sender)) {\\n            revert NotAuthorized();\\n        }\\n        _approveFor(owner, nonce, operator, tokenID);\\n    }\\n\\n    /// @inheritdoc IERC721\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenID\\n    ) external override {\\n        (address owner, uint256 nonce, bool operatorEnabled) = _ownerNonceAndOperatorEnabledOf(tokenID);\\n        if (owner == address(0)) {\\n            revert NonExistentToken(tokenID);\\n        }\\n        if (from != owner) {\\n            revert NotOwner(from, owner);\\n        }\\n        if (to == address(0) || to == address(this)) {\\n            revert InvalidAddress(to);\\n        }\\n        if (msg.sender != from) {\\n            if (!(operatorEnabled && _operators[tokenID] == msg.sender) && !isApprovedForAll(from, msg.sender)) {\\n                revert NotAuthorized();\\n            }\\n        }\\n        _transferFrom(from, to, tokenID, (nonce >> 24) != 0);\\n    }\\n\\n    /// @inheritdoc IERC721\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenID\\n    ) external override {\\n        safeTransferFrom(from, to, tokenID, \\\"\\\");\\n    }\\n\\n    /// @inheritdoc IERC721\\n    function setApprovalForAll(address operator, bool approved) external override {\\n        _setApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    /// @inheritdoc IERC721\\n    function balanceOf(address owner) public view virtual override returns (uint256 balance) {\\n        if (owner == address(0)) {\\n            revert InvalidAddress(owner);\\n        }\\n        balance = _balances[owner];\\n    }\\n\\n    /// @inheritdoc IERC721\\n    function ownerOf(uint256 tokenID) external view override returns (address owner) {\\n        owner = _ownerOf(tokenID);\\n        if (owner == address(0)) {\\n            revert NonExistentToken(tokenID);\\n        }\\n    }\\n\\n    /// @inheritdoc IERC721\\n    function getApproved(uint256 tokenID) external view override returns (address operator) {\\n        (address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(tokenID);\\n        if (owner == address(0)) {\\n            revert NonExistentToken(tokenID);\\n        }\\n        if (operatorEnabled) {\\n            return _operators[tokenID];\\n        } else {\\n            return address(0);\\n        }\\n    }\\n\\n    /// @inheritdoc IERC721\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool isOperator) {\\n        return _operatorsForAll[owner][operator];\\n    }\\n\\n    /// @inheritdoc IERC721\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenID,\\n        bytes memory data\\n    ) public override {\\n        (address owner, uint256 nonce, bool operatorEnabled) = _ownerNonceAndOperatorEnabledOf(tokenID);\\n        if (owner == address(0)) {\\n            revert NonExistentToken(tokenID);\\n        }\\n        if (owner != from) {\\n            revert NotOwner(from, owner);\\n        }\\n\\n        if (to == address(0) || to == address(this)) {\\n            revert InvalidAddress(to);\\n        }\\n\\n        if (msg.sender != from) {\\n            if (!(operatorEnabled && _operators[tokenID] == msg.sender) && !isApprovedForAll(from, msg.sender)) {\\n                revert NotAuthorized();\\n            }\\n        }\\n        _safeTransferFrom(from, to, tokenID, (nonce >> 24) != 0, data);\\n    }\\n\\n    /// @inheritdoc IERC165\\n    function supportsInterface(bytes4 interfaceID) public view virtual override returns (bool) {\\n        /// 0x01ffc9a7 is ERC165.\\n        /// 0x80ac58cd is ERC721\\n        /// 0x5b5e139f is for ERC721 metadata\\n        return interfaceID == 0x01ffc9a7 || interfaceID == 0x80ac58cd || interfaceID == 0x5b5e139f;\\n    }\\n\\n    /// @inheritdoc IERC721WithBlocknumber\\n    function ownerAndLastTransferBlockNumberOf(uint256 tokenID)\\n        external\\n        view\\n        override\\n        returns (address owner, uint256 blockNumber)\\n    {\\n        (address currentOwner, uint256 nonce) = _ownerAndNonceOf(tokenID);\\n        owner = currentOwner;\\n        blockNumber = (nonce >> 24);\\n    }\\n\\n    /// @inheritdoc IERC721WithBlocknumber\\n    function ownerAndLastTransferBlockNumberList(uint256[] calldata tokenIDs)\\n        external\\n        view\\n        virtual\\n        returns (OwnerData[] memory ownersData)\\n    {\\n        ownersData = new OwnerData[](tokenIDs.length);\\n        for (uint256 i = 0; i < tokenIDs.length; i++) {\\n            uint256 data = _owners[tokenIDs[i]];\\n            ownersData[i].owner = address(uint160(data));\\n            ownersData[i].lastTransferBlockNumber = (data >> 184) & 0xFFFFFFFFFFFFFFFF;\\n        }\\n    }\\n\\n    // ------------------------------------------------------------------------------------------------------------------\\n    // INTERNALS\\n    // ------------------------------------------------------------------------------------------------------------------\\n\\n    function _safeMint(address to, uint256 tokenID) internal {\\n        _safeTransferFrom(address(0), to, tokenID, false, \\\"\\\");\\n    }\\n\\n    function _safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenID,\\n        bool registered,\\n        bytes memory data\\n    ) internal {\\n        _transferFrom(from, to, tokenID, registered);\\n        if (to.isContract()) {\\n            if (!_checkOnERC721Received(msg.sender, from, to, tokenID, data)) {\\n                revert TransferRejected();\\n            }\\n        }\\n    }\\n\\n    function _transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenID,\\n        bool registered\\n    ) internal virtual {\\n        unchecked {\\n            _balances[to]++;\\n            if (registered) {\\n                _balances[from]--;\\n            }\\n        }\\n\\n        // We encode the blockNumber in the token nonce. We can then use it for count voting.\\n        _owners[tokenID] = (block.number << 184) | uint256(uint160(to));\\n        emit Transfer(from, to, tokenID);\\n    }\\n\\n    /// @dev See approve.\\n    function _approveFor(\\n        address owner,\\n        uint256 nonce,\\n        address operator,\\n        uint256 tokenID\\n    ) internal override {\\n        uint256 blockNumber = nonce >> 24;\\n        uint256 newNonce = nonce + 1;\\n        if (newNonce >> 24 != blockNumber) {\\n            revert NonceOverflow();\\n        }\\n        if (operator == address(0)) {\\n            _owners[tokenID] = (newNonce << 160) | uint256(uint160(owner));\\n        } else {\\n            _owners[tokenID] = OPERATOR_FLAG | ((newNonce << 160) | uint256(uint160(owner)));\\n            _operators[tokenID] = operator;\\n        }\\n        emit Approval(owner, operator, tokenID);\\n    }\\n\\n    /// @dev See setApprovalForAll.\\n    function _setApprovalForAll(\\n        address sender,\\n        address operator,\\n        bool approved\\n    ) internal override {\\n        _operatorsForAll[sender][operator] = approved;\\n\\n        emit ApprovalForAll(sender, operator, approved);\\n    }\\n\\n    /// @dev Check if receiving contract accepts erc721 transfers.\\n    /// @param operator The address of the operator.\\n    /// @param from The from address, may be different from msg.sender.\\n    /// @param to The adddress we want to transfer to.\\n    /// @param tokenID The id of the token we would like to transfer.\\n    /// @param data Any additional data to send with the transfer.\\n    /// @return Whether the expected value of 0x150b7a02 is returned.\\n    function _checkOnERC721Received(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 tokenID,\\n        bytes memory data\\n    ) internal returns (bool) {\\n        bytes4 retval = IERC721Receiver(to).onERC721Received(operator, from, tokenID, data);\\n        return (retval == ERC721_RECEIVED);\\n    }\\n\\n    /// @dev Get the owner of a token.\\n    /// @param tokenID The token to query.\\n    function _ownerOf(uint256 tokenID) internal view virtual returns (address owner) {\\n        return address(uint160(_owners[tokenID]));\\n    }\\n\\n    /// @dev Get the owner and operatorEnabled status of a token.\\n    /// @param tokenID The token to query.\\n    /// @return owner The owner of the token.\\n    /// @return operatorEnabled Whether or not operators are enabled for this token.\\n    function _ownerAndOperatorEnabledOf(uint256 tokenID)\\n        internal\\n        view\\n        virtual\\n        returns (address owner, bool operatorEnabled)\\n    {\\n        uint256 data = _owners[tokenID];\\n        owner = address(uint160(data));\\n        operatorEnabled = (data & OPERATOR_FLAG) == OPERATOR_FLAG;\\n    }\\n\\n    /// @dev Get the owner and the permit nonce of a token.\\n    /// @param tokenID The token to query.\\n    /// @return owner The owner of the token.\\n    /// @return nonce the nonce for permit (also incluse the blocknumer in the 64 higer bits (88 bits in total))\\n    function _ownerAndNonceOf(uint256 tokenID) internal view virtual override returns (address owner, uint256 nonce) {\\n        uint256 data = _owners[tokenID];\\n        owner = address(uint160(data));\\n        nonce = (data >> 160) & 0xFFFFFFFFFFFFFFFFFFFFFF;\\n    }\\n\\n    // @dev Get the owner, the permit nonce of a token and operatorEnabled status of a token.\\n    /// @param tokenID The token to query.\\n    /// @return owner The owner of the token.\\n    /// @return nonce the nonce for permit (also incluse the blocknumer in the 64 higer bits (88 bits in total))\\n    /// @return operatorEnabled Whether or not operators are enabled for this token.\\n    function _ownerNonceAndOperatorEnabledOf(uint256 tokenID)\\n        internal\\n        view\\n        virtual\\n        returns (\\n            address owner,\\n            uint256 nonce,\\n            bool operatorEnabled\\n        )\\n    {\\n        uint256 data = _owners[tokenID];\\n        owner = address(uint160(data));\\n        operatorEnabled = (data & OPERATOR_FLAG) == OPERATOR_FLAG;\\n        nonce = (data >> 160) & 0xFFFFFFFFFFFFFFFFFFFFFF;\\n    }\\n}\\n\",\"keccak256\":\"0xa479fafe6c08b94bf3d41b2e5e169bb8cf7f90033691a3903ec6fb13792e4e06\",\"license\":\"MIT\"},\"solidity-kit/solc_0.8/ERC721/implementations/ImplementingERC721Internal.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nabstract contract ImplementingERC721Internal {\\n    function _ownerAndNonceOf(uint256 tokenID) internal view virtual returns (address owner, uint256 nonce);\\n\\n    function _approveFor(\\n        address owner,\\n        uint256 nonce,\\n        address operator,\\n        uint256 tokenID\\n    ) internal virtual;\\n\\n    function _setApprovalForAll(\\n        address sender,\\n        address operator,\\n        bool approved\\n    ) internal virtual;\\n}\\n\",\"keccak256\":\"0xa8a6ed1a764da2589bd932b67174805ef0c47120d27fa4defc17a2368757efbe\",\"license\":\"MIT\"},\"solidity-kit/solc_0.8/ERC721/interfaces/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../ERC165/interfaces/IERC165.sol\\\";\\nimport \\\"../../utils/GenericErrors.sol\\\";\\n\\ninterface IERC721Supply {\\n    /// @notice return the total number of token in existence\\n    function totalSupply() external view returns (uint256);\\n}\\n\\ninterface IERC721 is IERC165 {\\n    /// @notice Triggered when a token is transferred\\n    /// @param from the account the token is sent from\\n    /// @param to the account the token is sent to\\n    /// @param tokenID id of the token being sent\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenID);\\n\\n    /// @notice Triggered when a token is approved to be sent by another account\\n    ///  Note tat the approval get reset when a Transfer event for that same token is emitted.\\n    /// @param owner current owner of the token\\n    /// @param approved account who can know transfer on the owner's behalf\\n    /// @param tokenID id of the token being approved\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenID);\\n\\n    /// @notice Triggered when an account approve or disaprove another to transfer on its behalf\\n    /// @param owner the account granting rights over all of its token\\n    /// @param operator account who can know transfer on the owner's behalf\\n    /// @param approved whether it is approved or not\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /// @notice The token does not exist\\n    /// @param tokenID id of the expected token\\n    error NonExistentToken(uint256 tokenID);\\n    /// @notice The address from which the token is sent is not the current owner\\n    /// @param provided the address expected to be the current owner\\n    /// @param currentOwner the current owner\\n    error NotOwner(address provided, address currentOwner);\\n    /// @notice An invalid address is specified (for example: zero address)\\n    /// @param addr invalid address\\n    error InvalidAddress(address addr);\\n    /// @notice The Transfer was rejected by the destination\\n    error TransferRejected();\\n    /// @notice The Nonce overflowed, make a transfer to self to allow new nonces.\\n    error NonceOverflow();\\n\\n    /// @notice Get the number of tokens owned by an address.\\n    /// @param owner The address to look for.\\n    /// @return balance The number of tokens owned by the address.\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /// @notice Get the owner of a token.\\n    /// @param tokenID The id of the token.\\n    /// @return owner The address of the token owner.\\n    function ownerOf(uint256 tokenID) external view returns (address owner);\\n\\n    /// @notice Transfer a token between 2 addresses letting the receiver knows of the transfer.\\n    /// @param from The sender of the token.\\n    /// @param to The recipient of the token.\\n    /// @param tokenID The id of the token.\\n    /// @param data Additional data.\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenID,\\n        bytes calldata data\\n    ) external;\\n\\n    /// @notice Transfer a token between 2 addresses letting the receiver know of the transfer.\\n    /// @param from The send of the token.\\n    /// @param to The recipient of the token.\\n    /// @param tokenID The id of the token.\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenID\\n    ) external;\\n\\n    /// @notice Transfer a token between 2 addresses.\\n    /// @param from The sender of the token.\\n    /// @param to The recipient of the token.\\n    /// @param tokenID The id of the token.\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenID\\n    ) external;\\n\\n    /// @notice Approve an operator to transfer a specific token on the senders behalf.\\n    /// @param operator The address receiving the approval.\\n    /// @param tokenID The id of the token.\\n    function approve(address operator, uint256 tokenID) external;\\n\\n    /// @notice Set the approval for an operator to manage all the tokens of the sender.\\n    /// @param operator The address receiving the approval.\\n    /// @param approved The determination of the approval.\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /// @notice Get the approved operator for a specific token.\\n    /// @param tokenID The id of the token.\\n    /// @return operator The address of the operator.\\n    function getApproved(uint256 tokenID) external view returns (address operator);\\n\\n    /// @notice Check if the sender approved the operator to transfer any of its tokens.\\n    /// @param owner The address of the owner.\\n    /// @param operator The address of the operator.\\n    /// @return isOperator The status of the approval.\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xfc57636452848e89a81850fe10e3ab1d5d7f5780d55ca0722a38fd59a44fd8ef\",\"license\":\"MIT\"},\"solidity-kit/solc_0.8/ERC721/interfaces/IERC721Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC721.sol\\\";\\n\\ninterface IERC721Metadata is IERC721 {\\n    /// @notice A descriptive name for a collection of NFTs in this contract\\n    function name() external view returns (string memory name);\\n\\n    /// @notice An abbreviated name for NFTs in this contract\\n    function symbol() external view returns (string memory symbol);\\n\\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\\n    /// @dev Throws if `tokenID` is not a valid NFT. URIs are defined in RFC\\n    ///  3986. The URI may point to a JSON file that conforms to the \\\"ERC721\\n    ///  Metadata JSON Schema\\\".\\n    /// @param tokenID id of the token being queried.\\n    function tokenURI(uint256 tokenID) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x8a4ff84c39ad5c6bbf3e5486d3687bc1e15b96835ede5761f1922cf7a72f3354\",\"license\":\"MIT\"},\"solidity-kit/solc_0.8/ERC721/interfaces/IERC721Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IERC721Receiver {\\n    /// @notice Handle the receipt of an NFT\\n    /// @dev The ERC721 smart contract calls this function on the recipient\\n    ///  after a `transfer`. This function MAY throw to revert and reject the\\n    ///  transfer. Return of other than the magic value MUST result in the\\n    ///  transaction being reverted.\\n    ///  Note: the contract address is always the message sender.\\n    /// @param operator The address which called `safeTransferFrom` function\\n    /// @param from The address which previously owned the token\\n    /// @param tokenID The NFT identifier which is being transferred\\n    /// @param data Additional data with no specified format\\n    /// @return `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\\n    ///  unless throwing\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenID,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0x47e1a42d5906cbc70c15f0352836dc7922d857632075c858f64e6286669a5e2e\",\"license\":\"MIT\"},\"solidity-kit/solc_0.8/ERC721/interfaces/IERC721WithBlocknumber.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IERC721WithBlocknumber {\\n    /// @notice Get the owner of a token and the blockNumber of the last transfer, useful to voting mechanism.\\n    /// @param tokenID The id of the token.\\n    /// @return owner The address of the token owner.\\n    /// @return blockNumber The blocknumber at which the last transfer of that id happened.\\n    function ownerAndLastTransferBlockNumberOf(uint256 tokenID)\\n        external\\n        view\\n        returns (address owner, uint256 blockNumber);\\n\\n    struct OwnerData {\\n        address owner;\\n        uint256 lastTransferBlockNumber;\\n    }\\n\\n    /// @notice Get the list of owner of a token and the blockNumber of its last transfer, useful to voting mechanism.\\n    /// @param tokenIDs The list of token ids to check.\\n    /// @return ownersData The list of (owner, lastTransferBlockNumber) for each ids given as input.\\n    function ownerAndLastTransferBlockNumberList(uint256[] calldata tokenIDs)\\n        external\\n        view\\n        returns (OwnerData[] memory ownersData);\\n}\\n\",\"keccak256\":\"0x2461ec24c55a1b6c13d451e52ad7600bc2da469996041700a3775efbcde7042b\",\"license\":\"MIT\"},\"solidity-kit/solc_0.8/openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Openzeppelin_Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x54a1b5eb6fdeb706049c5f570c398a49ea05f3da2d8e35f3ae344059d622350a\",\"license\":\"MIT\"},\"solidity-kit/solc_0.8/utils/GenericErrors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @notice Not authorized to perform this operation\\nerror NotAuthorized();\\n\",\"keccak256\":\"0x333aa48943e66849a9350384e7ec2553b93e8a8a12b8ad300d3341f7c98b60fd\",\"license\":\"MIT\"},\"solidity-proxy/solc_0.8/EIP1967/Proxied.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nabstract contract Proxied {\\n    /// @notice to be used by initialisation / postUpgrade function so that only the proxy's admin can execute them\\n    /// It also allows these functions to be called inside a contructor\\n    /// even if the contract is meant to be used without proxy\\n    modifier proxied() {\\n        address proxyAdminAddress = _proxyAdmin();\\n        // With hardhat-deploy proxies\\n        // the proxyAdminAddress is zero only for the implementation contract\\n        // if the implementation contract want to be used as a standalone/immutable contract\\n        // it simply has to execute the `proxied` function\\n        // This ensure the proxyAdminAddress is never zero post deployment\\n        // And allow you to keep the same code for both proxied contract and immutable contract\\n        if (proxyAdminAddress == address(0)) {\\n            // ensure can not be called twice when used outside of proxy : no admin\\n            // solhint-disable-next-line security/no-inline-assembly\\n            assembly {\\n                sstore(\\n                    0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103,\\n                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\\n                )\\n            }\\n        } else {\\n            require(msg.sender == proxyAdminAddress);\\n        }\\n        _;\\n    }\\n\\n    modifier onlyProxyAdmin() {\\n        require(msg.sender == _proxyAdmin(), \\\"NOT_AUTHORIZED\\\");\\n        _;\\n    }\\n\\n    function _proxyAdmin() internal view returns (address ownerAddress) {\\n        // solhint-disable-next-line security/no-inline-assembly\\n        assembly {\\n            ownerAddress := sload(0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xaaceeafeeaf0d200ca3942d8bf14c1c4f787a77f79cc87c08bb668e65acdee29\",\"license\":\"MIT\"},\"src/VitalikSecret.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport \\\"solidity-proxy/solc_0.8/EIP1967/Proxied.sol\\\";\\nimport \\\"solidity-kit/solc_0.8/ERC721/implementations/BasicERC721.sol\\\";\\nimport \\\"solidity-kit/solc_0.8/ERC721/interfaces/IERC721Metadata.sol\\\";\\nimport {UltraVerifier} from \\\"../zecret/contract/zecret/plonk_vk.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\n\\n/// @notice a puzzle\\ncontract VitalikSecret is BasicERC721, IERC721Metadata, Proxied {\\n    UltraVerifier zecret;\\n\\n    enum Move {\\n        RIGHT,\\n        DOWN,\\n        LEFT,\\n        UP\\n    }\\n\\n    uint256 public constant SIZE = 4;\\n\\n    uint256 immutable INITIAL_POSITION = 7;\\n    uint256 immutable FINAL_POSITION = 10;\\n\\n    uint256 public lowestNumberOfMoves;\\n\\n    function randomState() public view returns (uint8[SIZE * SIZE] memory) {\\n        uint8[SIZE * SIZE] memory state;\\n        uint256 randomBoardSize = state.length - 1;\\n        state[randomBoardSize] = 0;\\n        for (uint256 i = 0; i < randomBoardSize; i++) {\\n            state[i] = uint8(i + 1);\\n        }\\n        uint256 seed = randomSeed();\\n        for (uint256 i = 0; i < randomBoardSize; i++) {\\n            uint256 n = i + (uint256(keccak256(abi.encodePacked(seed))) % (randomBoardSize - i));\\n            uint8 temp = state[n];\\n            state[n] = state[i];\\n            state[i] = temp;\\n        }\\n        return state;\\n    }\\n\\n    function proposeSolution(Move[] calldata moves) external {\\n        uint8[SIZE * SIZE] memory state = [2, 4, 7, 3, 10, 9, 6, 0, 5, 1, 11, 8, 12, 13, 14, 15];\\n\\n        uint256 position = INITIAL_POSITION;\\n\\n        for (uint256 i = 0; i < moves.length; i++) {\\n            bool valid;\\n            uint256 oldPosition = position;\\n            (valid, position) = step(state, position, moves[i]);\\n            require(\\n                valid,\\n                string.concat(\\n                    \\\"invalid \\\",\\n                    Strings.toString(oldPosition),\\n                    \\\" => \\\",\\n                    Strings.toString(position),\\n                    \\\" : \\\",\\n                    Strings.toString(i)\\n                )\\n            );\\n        }\\n\\n        require(state[FINAL_POSITION] == 0, \\\"invalid solution (carret)\\\");\\n        for (uint256 i = 0; i < FINAL_POSITION; i++) {\\n            require(state[i] == i + 1, \\\"invalid solution 1/2\\\");\\n        }\\n        for (uint256 i = FINAL_POSITION + 1; i < state.length; i++) {\\n            require(state[i] == i, \\\"invalid solution 2/2\\\");\\n        }\\n\\n        require(lowestNumberOfMoves == 0 || moves.length < lowestNumberOfMoves, \\\"MAKE_BETTER_MOVE\\\");\\n        lowestNumberOfMoves = moves.length;\\n        _safeMint(msg.sender, moves.length);\\n    }\\n\\n    function proposeSolutionProof(uint256 numMoves, bytes calldata proof) external {\\n        bytes32[] memory publicInputs = new bytes32[](2);\\n        publicInputs[0] = bytes32(numMoves);\\n        publicInputs[1] = bytes32(uint256(uint160(msg.sender)));\\n        require(lowestNumberOfMoves == 0 || numMoves < lowestNumberOfMoves, \\\"MAKE_BETTER_MOVE\\\");\\n        lowestNumberOfMoves = numMoves;\\n        _safeMint(msg.sender, numMoves);\\n    }\\n\\n    function step(\\n        uint8[SIZE * SIZE] memory currentState,\\n        uint256 position,\\n        Move move\\n    ) internal returns (bool valid, uint256 newPosition) {\\n        uint256 x = position % SIZE;\\n        uint256 y = position / SIZE;\\n        if (move == Move.RIGHT) {\\n            if (x < SIZE - 1) {\\n                valid = true;\\n                newPosition = y * SIZE + x + 1;\\n                _swap(currentState, position, newPosition);\\n            }\\n        } else if (move == Move.DOWN) {\\n            if (y < SIZE - 1) {\\n                valid = true;\\n                newPosition = (y + 1) * SIZE + x;\\n                _swap(currentState, position, newPosition);\\n            }\\n        } else if (move == Move.LEFT) {\\n            if (x > 0) {\\n                valid = true;\\n                newPosition = y * SIZE + x - 1;\\n                _swap(currentState, position, newPosition);\\n            }\\n        } else if (move == Move.UP) {\\n            if (y > 0) {\\n                valid = true;\\n                newPosition = (y - 1) * SIZE + x;\\n                _swap(currentState, position, newPosition);\\n            }\\n        } else {\\n            valid = false;\\n        }\\n    }\\n\\n    function tokenURI(uint256 tokenID) external pure returns (string memory) {\\n        string memory name = \\\"Vitalik's%20secret\\\";\\n        return\\n            string(\\n                string.concat(\\n                    'data:application/json,{\\\"name\\\":\\\"',\\n                    name,\\n                    '\\\",\\\"description\\\":\\\"',\\n                    name,\\n                    '\\\",\\\"image\\\":\\\"',\\n                    \\\"data:image/svg+xml,<svg%2520viewBox='0%25200%252032%252016'%2520xmlns='http://www.w3.org/2000/svg'><text%2520x='50%'%2520y='50%'%2520dominant-baseline='middle'%2520text-anchor='middle'%2520style='fill:rgb(219,39,119);font-size:2px;'>\\\",\\n                    Strings.toString(tokenID),\\n                    \\\"%20\\\",\\n                    \\\"moves\\\",\\n                    \\\"</text></svg>\\\"\\n                    '\\\"}'\\n                )\\n            );\\n    }\\n\\n    // TODO remove\\n    function testMint(uint256 numMoves) external {\\n        if (lowestNumberOfMoves == 0 || numMoves < lowestNumberOfMoves) {\\n            lowestNumberOfMoves = numMoves;\\n        }\\n        _safeMint(msg.sender, numMoves);\\n    }\\n\\n    function name() external pure returns (string memory) {\\n        return \\\"VITALIK SECRET\\\";\\n    }\\n\\n    function symbol() external pure returns (string memory) {\\n        return \\\"VTS\\\";\\n    }\\n\\n    function _swap(uint8[SIZE * SIZE] memory data, uint256 a, uint256 b) internal pure {\\n        uint8 aValue = data[a];\\n        uint8 bValue = data[b];\\n        data[a] = bValue;\\n        data[b] = aValue;\\n    }\\n\\n    function bytes32ToHexString(bytes32 _bytes32) public pure returns (string memory) {\\n        // Convert bytes32 to bytes memory\\n        bytes memory bytesArray = new bytes(32);\\n        for (uint256 i = 0; i < 32; i++) {\\n            bytesArray[i] = _bytes32[i];\\n        }\\n\\n        // Convert bytes to hex string\\n        bytes memory hexChars = \\\"0123456789abcdef\\\";\\n        bytes memory hexString = new bytes(64);\\n        for (uint256 j = 0; j < 32; j++) {\\n            hexString[j * 2] = hexChars[uint8(bytesArray[j] >> 4)];\\n            hexString[j * 2 + 1] = hexChars[uint8(bytesArray[j] & 0x0f)];\\n        }\\n\\n        return string(hexString);\\n    }\\n\\n    function randomSeed() internal view returns (uint256) {\\n        return 42;\\n    }\\n}\\n\",\"keccak256\":\"0xd7efaf489252f602d6421ac61d875bf1446225e1264c01c91ab6bd2ea1a11999\",\"license\":\"MIT\"},\"zecret/contract/zecret/plonk_vk.sol\":{\"content\":\"// Verification Key Hash: 3ffe0dd91c2bc9de3ec113ca6c6c65372d4775bf81c60a9befedb3731d68f498\\n// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec\\npragma solidity >=0.8.4;\\n\\nlibrary UltraVerificationKey {\\n    function verificationKeyHash() internal pure returns(bytes32) {\\n        return 0x3ffe0dd91c2bc9de3ec113ca6c6c65372d4775bf81c60a9befedb3731d68f498;\\n    }\\n\\n    function loadVerificationKey(uint256 _vk, uint256 _omegaInverseLoc) internal pure {\\n        assembly {\\n            mstore(add(_vk, 0x00), 0x0000000000000000000000000000000000000000000000000000000000040000) // vk.circuit_size\\n            mstore(add(_vk, 0x20), 0x0000000000000000000000000000000000000000000000000000000000000001) // vk.num_inputs\\n            mstore(add(_vk, 0x40), 0x19ddbcaf3a8d46c15c0176fbb5b95e4dc57088ff13f4d1bd84c6bfa57dcdc0e0) // vk.work_root\\n            mstore(add(_vk, 0x60), 0x30644259cd94e7dd5045d7a27013b7fcd21c9e3b7fa75222e7bda49b729b0401) // vk.domain_inverse\\n            mstore(add(_vk, 0x80), 0x134d8f6895e12f51cc46142aea290fcbc08c7045a5f8e4014fa982870eeda5cd) // vk.Q1.x\\n            mstore(add(_vk, 0xa0), 0x0e9370fcb0f9cbfa4d77960503e533a3227353439e15b53164d813e57c923c20) // vk.Q1.y\\n            mstore(add(_vk, 0xc0), 0x221bd54b5fbb95d159776d5324b53ab6683c671736b19abe9d0a99c714eec121) // vk.Q2.x\\n            mstore(add(_vk, 0xe0), 0x026dd67f2ff9b4694c0f38e6037a04d10b16fc428fef96c8afcd07057d543d21) // vk.Q2.y\\n            mstore(add(_vk, 0x100), 0x2ad84c1e303916e2d5060747ec55af95773b26206302a40082b7ee9cbb2172df) // vk.Q3.x\\n            mstore(add(_vk, 0x120), 0x13d75b0a27b0951fc127ade08b40a601ddc71ec3e5e9fd14c1522667ae728d96) // vk.Q3.y\\n            mstore(add(_vk, 0x140), 0x2821816f0471dea542807f86e87dcd88890d7b7d4add676c1b34245d5dbae40c) // vk.Q4.x\\n            mstore(add(_vk, 0x160), 0x0606951a7dbb48e029ace9c5a03508aafdb68d5c68834485574473e357ebd59d) // vk.Q4.y\\n            mstore(add(_vk, 0x180), 0x10a3a5abcb492fb020beb73df152a2350a2df0b97e77487aa4e687d2c3c2ab09) // vk.Q_M.x\\n            mstore(add(_vk, 0x1a0), 0x28be5911df1e80ffdfc7a61c66e3bbfce43d2c7ef73f6898d1d9926f91fb5f41) // vk.Q_M.y\\n            mstore(add(_vk, 0x1c0), 0x2622024c5608af808fa5663a161a6a72729030490816bfe0a682ba3737672d89) // vk.Q_C.x\\n            mstore(add(_vk, 0x1e0), 0x1e20cd31c206777237450a8168ee18572781f0e5cc20b083a2dde6c8f77306ab) // vk.Q_C.y\\n            mstore(add(_vk, 0x200), 0x1805227b2d99135962cddf22eabba746c84ac4f358d948c51d896824521b6d92) // vk.Q_ARITHMETIC.x\\n            mstore(add(_vk, 0x220), 0x0b3d4d3729a49ab4efcd606437cdc68140b240e06eb28af44353ba28814fd7ca) // vk.Q_ARITHMETIC.y\\n            mstore(add(_vk, 0x240), 0x21800cc7641927018f57515e8db867fad0937a8078c30e0f5aba8f8227b1e775) // vk.QSORT.x\\n            mstore(add(_vk, 0x260), 0x10dc339f2ad0576951a260b50552f973ec6684f1615ec87b052749efe5ed796c) // vk.QSORT.y\\n            mstore(add(_vk, 0x280), 0x2d5247c138f521f72a738d5497ad48d7fac4e2369d9a8e99a9b9f8070d931963) // vk.Q_ELLIPTIC.x\\n            mstore(add(_vk, 0x2a0), 0x055c8ea419d61ab8dcc3533ad944e83262d0648c1864002d48a5f4907aa301a4) // vk.Q_ELLIPTIC.y\\n            mstore(add(_vk, 0x2c0), 0x17ba5c19d0196255ee775dced39f3d9d4c98087c0b7a9536513cba935a0226ba) // vk.Q_AUX.x\\n            mstore(add(_vk, 0x2e0), 0x1811334bc7a67b167bef9c9a3cefcd1d698fde8bd7dfdd4694f548df3d0a5325) // vk.Q_AUX.y\\n            mstore(add(_vk, 0x300), 0x1d34786532871fa7bb9588faad3c792e2853c489aaed1e980f19e39d81210e28) // vk.SIGMA1.x\\n            mstore(add(_vk, 0x320), 0x23e79de86402ca5b5ce655de4d0a06eac574c81e7660054aca1f71f5ea79f711) // vk.SIGMA1.y\\n            mstore(add(_vk, 0x340), 0x203dc2866e9a1cae16249e6398aece5a9e5cdf6a8eca04311cf636fd423b1f43) // vk.SIGMA2.x\\n            mstore(add(_vk, 0x360), 0x0793092fe148e9d3250c224a2b99d6b366478a4854971936e21997feb6f3eea6) // vk.SIGMA2.y\\n            mstore(add(_vk, 0x380), 0x256f4850bb5fff09a6939e43e9b6504276228930a101fdda5eb615aa2a84907f) // vk.SIGMA3.x\\n            mstore(add(_vk, 0x3a0), 0x17c0ceb17701bd04bc8d3c0762b98e4ebf5c4a421c9a454c203aa555eb6fdea9) // vk.SIGMA3.y\\n            mstore(add(_vk, 0x3c0), 0x245dc4abf851a452f728100b2fd052fd519484e47fdfd0f821d9d4345a03a96a) // vk.SIGMA4.x\\n            mstore(add(_vk, 0x3e0), 0x2bd42d902599fa696a66bcc65d2d0143a036700b477ba1dff0522c395e1be0b0) // vk.SIGMA4.y\\n            mstore(add(_vk, 0x400), 0x192711fca2f5b36970aae483f46068b91f52060c02f8325294db54bb0a11933e) // vk.TABLE1.x\\n            mstore(add(_vk, 0x420), 0x1bff24689c6227448a09dbed17ef39405aa88aedd9f9384dfe3f3d0a0480cbac) // vk.TABLE1.y\\n            mstore(add(_vk, 0x440), 0x194b5ba84c106e0146f0952b5454de8274ff80a9f83cf14c4f6f0742eeb19864) // vk.TABLE2.x\\n            mstore(add(_vk, 0x460), 0x1ec2dc36740cd8f027ac2c850a042d4482e3b79c8105eef51df522056ae7605a) // vk.TABLE2.y\\n            mstore(add(_vk, 0x480), 0x2263709bd57b4b6419d0e9ddb56ac9c9419a18e11184552647e1788e62f3daf3) // vk.TABLE3.x\\n            mstore(add(_vk, 0x4a0), 0x28473c39c8ad63fc67af038fa2594679efec0bf7da69050d9ddee43a5837f731) // vk.TABLE3.y\\n            mstore(add(_vk, 0x4c0), 0x0c55dfdec4ea5722f75304d9d07d41349451120f02efda3f0355fc1c953256c6) // vk.TABLE4.x\\n            mstore(add(_vk, 0x4e0), 0x2018b108aefa236db9e8d68ca15fd206e209683379f8cb36fe3a8a7d0456bf08) // vk.TABLE4.y\\n            mstore(add(_vk, 0x500), 0x044840c394aea0c66af2b47aacc5c67b7f95b1b817e8215ff706e6adf02370fd) // vk.TABLE_TYPE.x\\n            mstore(add(_vk, 0x520), 0x1b231e208d637332ff2182fe11f11404be27e4c2486620025dbaefe957144cbe) // vk.TABLE_TYPE.y\\n            mstore(add(_vk, 0x540), 0x16cc54723074d277e0cd914c05732c59b419d30e4ad985b7e43d555b237f4cea) // vk.ID1.x\\n            mstore(add(_vk, 0x560), 0x2dde53ad42bd16676b2b66a7197c17e258489e7ef9235d2465498e184da4ed60) // vk.ID1.y\\n            mstore(add(_vk, 0x580), 0x2e58179127ebe7b9be794bf58b4452370f79dc0a7f1196ee2ab983ff2296fd41) // vk.ID2.x\\n            mstore(add(_vk, 0x5a0), 0x0157125afcf9dae5e5c004acc44642de4eb9646756ac4455a70ccbbbc0b73c2c) // vk.ID2.y\\n            mstore(add(_vk, 0x5c0), 0x09c55a0870daff94f286ec001955f53451f8db99dee1619f12ac9a96023de436) // vk.ID3.x\\n            mstore(add(_vk, 0x5e0), 0x147a7f0065119168647d8bf7625b10d84124b2c3b518ff1f3a930a8d9c016aa0) // vk.ID3.y\\n            mstore(add(_vk, 0x600), 0x271ba6458b139743112958be5735c13bf05cffbcde23857b921c236df4890caf) // vk.ID4.x\\n            mstore(add(_vk, 0x620), 0x00ed05b53b5e5b48112026774127f0d77c2b25a1cdc18a50981ab1f6c33cb8be) // vk.ID4.y\\n            mstore(add(_vk, 0x640), 0x00) // vk.contains_recursive_proof\\n            mstore(add(_vk, 0x660), 0) // vk.recursive_proof_public_input_indices\\n            mstore(add(_vk, 0x680), 0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1) // vk.g2_x.X.c1 \\n            mstore(add(_vk, 0x6a0), 0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0) // vk.g2_x.X.c0 \\n            mstore(add(_vk, 0x6c0), 0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4) // vk.g2_x.Y.c1 \\n            mstore(add(_vk, 0x6e0), 0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55) // vk.g2_x.Y.c0 \\n            mstore(_omegaInverseLoc, 0x036853f083780e87f8d7c71d111119c57dbe118c22d5ad707a82317466c5174c) // vk.work_root_inverse\\n        }\\n    }\\n}\\n/**\\n * @title Ultra Plonk proof verification contract\\n * @dev Top level Plonk proof verification contract, which allows Plonk proof to be verified\\n */\\nabstract contract BaseUltraVerifier {\\n    // VERIFICATION KEY MEMORY LOCATIONS\\n    uint256 internal constant N_LOC = 0x380;\\n    uint256 internal constant NUM_INPUTS_LOC = 0x3a0;\\n    uint256 internal constant OMEGA_LOC = 0x3c0;\\n    uint256 internal constant DOMAIN_INVERSE_LOC = 0x3e0;\\n    uint256 internal constant Q1_X_LOC = 0x400;\\n    uint256 internal constant Q1_Y_LOC = 0x420;\\n    uint256 internal constant Q2_X_LOC = 0x440;\\n    uint256 internal constant Q2_Y_LOC = 0x460;\\n    uint256 internal constant Q3_X_LOC = 0x480;\\n    uint256 internal constant Q3_Y_LOC = 0x4a0;\\n    uint256 internal constant Q4_X_LOC = 0x4c0;\\n    uint256 internal constant Q4_Y_LOC = 0x4e0;\\n    uint256 internal constant QM_X_LOC = 0x500;\\n    uint256 internal constant QM_Y_LOC = 0x520;\\n    uint256 internal constant QC_X_LOC = 0x540;\\n    uint256 internal constant QC_Y_LOC = 0x560;\\n    uint256 internal constant QARITH_X_LOC = 0x580;\\n    uint256 internal constant QARITH_Y_LOC = 0x5a0;\\n    uint256 internal constant QSORT_X_LOC = 0x5c0;\\n    uint256 internal constant QSORT_Y_LOC = 0x5e0;\\n    uint256 internal constant QELLIPTIC_X_LOC = 0x600;\\n    uint256 internal constant QELLIPTIC_Y_LOC = 0x620;\\n    uint256 internal constant QAUX_X_LOC = 0x640;\\n    uint256 internal constant QAUX_Y_LOC = 0x660;\\n    uint256 internal constant SIGMA1_X_LOC = 0x680;\\n    uint256 internal constant SIGMA1_Y_LOC = 0x6a0;\\n    uint256 internal constant SIGMA2_X_LOC = 0x6c0;\\n    uint256 internal constant SIGMA2_Y_LOC = 0x6e0;\\n    uint256 internal constant SIGMA3_X_LOC = 0x700;\\n    uint256 internal constant SIGMA3_Y_LOC = 0x720;\\n    uint256 internal constant SIGMA4_X_LOC = 0x740;\\n    uint256 internal constant SIGMA4_Y_LOC = 0x760;\\n    uint256 internal constant TABLE1_X_LOC = 0x780;\\n    uint256 internal constant TABLE1_Y_LOC = 0x7a0;\\n    uint256 internal constant TABLE2_X_LOC = 0x7c0;\\n    uint256 internal constant TABLE2_Y_LOC = 0x7e0;\\n    uint256 internal constant TABLE3_X_LOC = 0x800;\\n    uint256 internal constant TABLE3_Y_LOC = 0x820;\\n    uint256 internal constant TABLE4_X_LOC = 0x840;\\n    uint256 internal constant TABLE4_Y_LOC = 0x860;\\n    uint256 internal constant TABLE_TYPE_X_LOC = 0x880;\\n    uint256 internal constant TABLE_TYPE_Y_LOC = 0x8a0;\\n    uint256 internal constant ID1_X_LOC = 0x8c0;\\n    uint256 internal constant ID1_Y_LOC = 0x8e0;\\n    uint256 internal constant ID2_X_LOC = 0x900;\\n    uint256 internal constant ID2_Y_LOC = 0x920;\\n    uint256 internal constant ID3_X_LOC = 0x940;\\n    uint256 internal constant ID3_Y_LOC = 0x960;\\n    uint256 internal constant ID4_X_LOC = 0x980;\\n    uint256 internal constant ID4_Y_LOC = 0x9a0;\\n    uint256 internal constant CONTAINS_RECURSIVE_PROOF_LOC = 0x9c0;\\n    uint256 internal constant RECURSIVE_PROOF_PUBLIC_INPUT_INDICES_LOC = 0x9e0;\\n    uint256 internal constant G2X_X0_LOC = 0xa00;\\n    uint256 internal constant G2X_X1_LOC = 0xa20;\\n    uint256 internal constant G2X_Y0_LOC = 0xa40;\\n    uint256 internal constant G2X_Y1_LOC = 0xa60;\\n\\n    // ### PROOF DATA MEMORY LOCATIONS\\n    uint256 internal constant W1_X_LOC = 0x1200;\\n    uint256 internal constant W1_Y_LOC = 0x1220;\\n    uint256 internal constant W2_X_LOC = 0x1240;\\n    uint256 internal constant W2_Y_LOC = 0x1260;\\n    uint256 internal constant W3_X_LOC = 0x1280;\\n    uint256 internal constant W3_Y_LOC = 0x12a0;\\n    uint256 internal constant W4_X_LOC = 0x12c0;\\n    uint256 internal constant W4_Y_LOC = 0x12e0;\\n    uint256 internal constant S_X_LOC = 0x1300;\\n    uint256 internal constant S_Y_LOC = 0x1320;\\n    uint256 internal constant Z_X_LOC = 0x1340;\\n    uint256 internal constant Z_Y_LOC = 0x1360;\\n    uint256 internal constant Z_LOOKUP_X_LOC = 0x1380;\\n    uint256 internal constant Z_LOOKUP_Y_LOC = 0x13a0;\\n    uint256 internal constant T1_X_LOC = 0x13c0;\\n    uint256 internal constant T1_Y_LOC = 0x13e0;\\n    uint256 internal constant T2_X_LOC = 0x1400;\\n    uint256 internal constant T2_Y_LOC = 0x1420;\\n    uint256 internal constant T3_X_LOC = 0x1440;\\n    uint256 internal constant T3_Y_LOC = 0x1460;\\n    uint256 internal constant T4_X_LOC = 0x1480;\\n    uint256 internal constant T4_Y_LOC = 0x14a0;\\n\\n    uint256 internal constant W1_EVAL_LOC = 0x1600;\\n    uint256 internal constant W2_EVAL_LOC = 0x1620;\\n    uint256 internal constant W3_EVAL_LOC = 0x1640;\\n    uint256 internal constant W4_EVAL_LOC = 0x1660;\\n    uint256 internal constant S_EVAL_LOC = 0x1680;\\n    uint256 internal constant Z_EVAL_LOC = 0x16a0;\\n    uint256 internal constant Z_LOOKUP_EVAL_LOC = 0x16c0;\\n    uint256 internal constant Q1_EVAL_LOC = 0x16e0;\\n    uint256 internal constant Q2_EVAL_LOC = 0x1700;\\n    uint256 internal constant Q3_EVAL_LOC = 0x1720;\\n    uint256 internal constant Q4_EVAL_LOC = 0x1740;\\n    uint256 internal constant QM_EVAL_LOC = 0x1760;\\n    uint256 internal constant QC_EVAL_LOC = 0x1780;\\n    uint256 internal constant QARITH_EVAL_LOC = 0x17a0;\\n    uint256 internal constant QSORT_EVAL_LOC = 0x17c0;\\n    uint256 internal constant QELLIPTIC_EVAL_LOC = 0x17e0;\\n    uint256 internal constant QAUX_EVAL_LOC = 0x1800;\\n    uint256 internal constant TABLE1_EVAL_LOC = 0x1840;\\n    uint256 internal constant TABLE2_EVAL_LOC = 0x1860;\\n    uint256 internal constant TABLE3_EVAL_LOC = 0x1880;\\n    uint256 internal constant TABLE4_EVAL_LOC = 0x18a0;\\n    uint256 internal constant TABLE_TYPE_EVAL_LOC = 0x18c0;\\n    uint256 internal constant ID1_EVAL_LOC = 0x18e0;\\n    uint256 internal constant ID2_EVAL_LOC = 0x1900;\\n    uint256 internal constant ID3_EVAL_LOC = 0x1920;\\n    uint256 internal constant ID4_EVAL_LOC = 0x1940;\\n    uint256 internal constant SIGMA1_EVAL_LOC = 0x1960;\\n    uint256 internal constant SIGMA2_EVAL_LOC = 0x1980;\\n    uint256 internal constant SIGMA3_EVAL_LOC = 0x19a0;\\n    uint256 internal constant SIGMA4_EVAL_LOC = 0x19c0;\\n    uint256 internal constant W1_OMEGA_EVAL_LOC = 0x19e0;\\n    uint256 internal constant W2_OMEGA_EVAL_LOC = 0x2000;\\n    uint256 internal constant W3_OMEGA_EVAL_LOC = 0x2020;\\n    uint256 internal constant W4_OMEGA_EVAL_LOC = 0x2040;\\n    uint256 internal constant S_OMEGA_EVAL_LOC = 0x2060;\\n    uint256 internal constant Z_OMEGA_EVAL_LOC = 0x2080;\\n    uint256 internal constant Z_LOOKUP_OMEGA_EVAL_LOC = 0x20a0;\\n    uint256 internal constant TABLE1_OMEGA_EVAL_LOC = 0x20c0;\\n    uint256 internal constant TABLE2_OMEGA_EVAL_LOC = 0x20e0;\\n    uint256 internal constant TABLE3_OMEGA_EVAL_LOC = 0x2100;\\n    uint256 internal constant TABLE4_OMEGA_EVAL_LOC = 0x2120;\\n\\n    uint256 internal constant PI_Z_X_LOC = 0x2300;\\n    uint256 internal constant PI_Z_Y_LOC = 0x2320;\\n    uint256 internal constant PI_Z_OMEGA_X_LOC = 0x2340;\\n    uint256 internal constant PI_Z_OMEGA_Y_LOC = 0x2360;\\n\\n    // Used for elliptic widget. These are alias names for wire + shifted wire evaluations\\n    uint256 internal constant X1_EVAL_LOC = W2_EVAL_LOC;\\n    uint256 internal constant X2_EVAL_LOC = W1_OMEGA_EVAL_LOC;\\n    uint256 internal constant X3_EVAL_LOC = W2_OMEGA_EVAL_LOC;\\n    uint256 internal constant Y1_EVAL_LOC = W3_EVAL_LOC;\\n    uint256 internal constant Y2_EVAL_LOC = W4_OMEGA_EVAL_LOC;\\n    uint256 internal constant Y3_EVAL_LOC = W3_OMEGA_EVAL_LOC;\\n    uint256 internal constant QBETA_LOC = Q3_EVAL_LOC;\\n    uint256 internal constant QBETA_SQR_LOC = Q4_EVAL_LOC;\\n    uint256 internal constant QSIGN_LOC = Q1_EVAL_LOC;\\n\\n    // ### CHALLENGES MEMORY OFFSETS\\n\\n    uint256 internal constant C_BETA_LOC = 0x2600;\\n    uint256 internal constant C_GAMMA_LOC = 0x2620;\\n    uint256 internal constant C_ALPHA_LOC = 0x2640;\\n    uint256 internal constant C_ETA_LOC = 0x2660;\\n    uint256 internal constant C_ETA_SQR_LOC = 0x2680;\\n    uint256 internal constant C_ETA_CUBE_LOC = 0x26a0;\\n\\n    uint256 internal constant C_ZETA_LOC = 0x26c0;\\n    uint256 internal constant C_CURRENT_LOC = 0x26e0;\\n    uint256 internal constant C_V0_LOC = 0x2700;\\n    uint256 internal constant C_V1_LOC = 0x2720;\\n    uint256 internal constant C_V2_LOC = 0x2740;\\n    uint256 internal constant C_V3_LOC = 0x2760;\\n    uint256 internal constant C_V4_LOC = 0x2780;\\n    uint256 internal constant C_V5_LOC = 0x27a0;\\n    uint256 internal constant C_V6_LOC = 0x27c0;\\n    uint256 internal constant C_V7_LOC = 0x27e0;\\n    uint256 internal constant C_V8_LOC = 0x2800;\\n    uint256 internal constant C_V9_LOC = 0x2820;\\n    uint256 internal constant C_V10_LOC = 0x2840;\\n    uint256 internal constant C_V11_LOC = 0x2860;\\n    uint256 internal constant C_V12_LOC = 0x2880;\\n    uint256 internal constant C_V13_LOC = 0x28a0;\\n    uint256 internal constant C_V14_LOC = 0x28c0;\\n    uint256 internal constant C_V15_LOC = 0x28e0;\\n    uint256 internal constant C_V16_LOC = 0x2900;\\n    uint256 internal constant C_V17_LOC = 0x2920;\\n    uint256 internal constant C_V18_LOC = 0x2940;\\n    uint256 internal constant C_V19_LOC = 0x2960;\\n    uint256 internal constant C_V20_LOC = 0x2980;\\n    uint256 internal constant C_V21_LOC = 0x29a0;\\n    uint256 internal constant C_V22_LOC = 0x29c0;\\n    uint256 internal constant C_V23_LOC = 0x29e0;\\n    uint256 internal constant C_V24_LOC = 0x2a00;\\n    uint256 internal constant C_V25_LOC = 0x2a20;\\n    uint256 internal constant C_V26_LOC = 0x2a40;\\n    uint256 internal constant C_V27_LOC = 0x2a60;\\n    uint256 internal constant C_V28_LOC = 0x2a80;\\n    uint256 internal constant C_V29_LOC = 0x2aa0;\\n    uint256 internal constant C_V30_LOC = 0x2ac0;\\n\\n    uint256 internal constant C_U_LOC = 0x2b00;\\n\\n    // ### LOCAL VARIABLES MEMORY OFFSETS\\n    uint256 internal constant DELTA_NUMERATOR_LOC = 0x3000;\\n    uint256 internal constant DELTA_DENOMINATOR_LOC = 0x3020;\\n    uint256 internal constant ZETA_POW_N_LOC = 0x3040;\\n    uint256 internal constant PUBLIC_INPUT_DELTA_LOC = 0x3060;\\n    uint256 internal constant ZERO_POLY_LOC = 0x3080;\\n    uint256 internal constant L_START_LOC = 0x30a0;\\n    uint256 internal constant L_END_LOC = 0x30c0;\\n    uint256 internal constant R_ZERO_EVAL_LOC = 0x30e0;\\n\\n    uint256 internal constant PLOOKUP_DELTA_NUMERATOR_LOC = 0x3100;\\n    uint256 internal constant PLOOKUP_DELTA_DENOMINATOR_LOC = 0x3120;\\n    uint256 internal constant PLOOKUP_DELTA_LOC = 0x3140;\\n\\n    uint256 internal constant ACCUMULATOR_X_LOC = 0x3160;\\n    uint256 internal constant ACCUMULATOR_Y_LOC = 0x3180;\\n    uint256 internal constant ACCUMULATOR2_X_LOC = 0x31a0;\\n    uint256 internal constant ACCUMULATOR2_Y_LOC = 0x31c0;\\n    uint256 internal constant PAIRING_LHS_X_LOC = 0x31e0;\\n    uint256 internal constant PAIRING_LHS_Y_LOC = 0x3200;\\n    uint256 internal constant PAIRING_RHS_X_LOC = 0x3220;\\n    uint256 internal constant PAIRING_RHS_Y_LOC = 0x3240;\\n\\n    // ### SUCCESS FLAG MEMORY LOCATIONS\\n    uint256 internal constant GRAND_PRODUCT_SUCCESS_FLAG = 0x3300;\\n    uint256 internal constant ARITHMETIC_TERM_SUCCESS_FLAG = 0x3020;\\n    uint256 internal constant BATCH_OPENING_SUCCESS_FLAG = 0x3340;\\n    uint256 internal constant OPENING_COMMITMENT_SUCCESS_FLAG = 0x3360;\\n    uint256 internal constant PAIRING_PREAMBLE_SUCCESS_FLAG = 0x3380;\\n    uint256 internal constant PAIRING_SUCCESS_FLAG = 0x33a0;\\n    uint256 internal constant RESULT_FLAG = 0x33c0;\\n\\n    // misc stuff\\n    uint256 internal constant OMEGA_INVERSE_LOC = 0x3400;\\n    uint256 internal constant C_ALPHA_SQR_LOC = 0x3420;\\n    uint256 internal constant C_ALPHA_CUBE_LOC = 0x3440;\\n    uint256 internal constant C_ALPHA_QUAD_LOC = 0x3460;\\n    uint256 internal constant C_ALPHA_BASE_LOC = 0x3480;\\n\\n    // ### RECURSION VARIABLE MEMORY LOCATIONS\\n    uint256 internal constant RECURSIVE_P1_X_LOC = 0x3500;\\n    uint256 internal constant RECURSIVE_P1_Y_LOC = 0x3520;\\n    uint256 internal constant RECURSIVE_P2_X_LOC = 0x3540;\\n    uint256 internal constant RECURSIVE_P2_Y_LOC = 0x3560;\\n\\n    uint256 internal constant PUBLIC_INPUTS_HASH_LOCATION = 0x3580;\\n\\n    // sub-identity storage\\n    uint256 internal constant PERMUTATION_IDENTITY = 0x3600;\\n    uint256 internal constant PLOOKUP_IDENTITY = 0x3620;\\n    uint256 internal constant ARITHMETIC_IDENTITY = 0x3640;\\n    uint256 internal constant SORT_IDENTITY = 0x3660;\\n    uint256 internal constant ELLIPTIC_IDENTITY = 0x3680;\\n    uint256 internal constant AUX_IDENTITY = 0x36a0;\\n    uint256 internal constant AUX_NON_NATIVE_FIELD_EVALUATION = 0x36c0;\\n    uint256 internal constant AUX_LIMB_ACCUMULATOR_EVALUATION = 0x36e0;\\n    uint256 internal constant AUX_RAM_CONSISTENCY_EVALUATION = 0x3700;\\n    uint256 internal constant AUX_ROM_CONSISTENCY_EVALUATION = 0x3720;\\n    uint256 internal constant AUX_MEMORY_EVALUATION = 0x3740;\\n\\n    uint256 internal constant QUOTIENT_EVAL_LOC = 0x3760;\\n    uint256 internal constant ZERO_POLY_INVERSE_LOC = 0x3780;\\n\\n    // when hashing public inputs we use memory at NU_CHALLENGE_INPUT_LOC_A, as the hash input size is unknown at compile time\\n    uint256 internal constant NU_CHALLENGE_INPUT_LOC_A = 0x37a0;\\n    uint256 internal constant NU_CHALLENGE_INPUT_LOC_B = 0x37c0;\\n    uint256 internal constant NU_CHALLENGE_INPUT_LOC_C = 0x37e0;\\n\\n    bytes4 internal constant PUBLIC_INPUT_INVALID_BN128_G1_POINT_SELECTOR = 0xeba9f4a6;\\n    bytes4 internal constant PUBLIC_INPUT_GE_P_SELECTOR = 0x374a972f;\\n    bytes4 internal constant MOD_EXP_FAILURE_SELECTOR = 0xf894a7bc;\\n    bytes4 internal constant EC_SCALAR_MUL_FAILURE_SELECTOR = 0xf755f369;\\n    bytes4 internal constant PROOF_FAILURE_SELECTOR = 0x0711fcec;\\n\\n    uint256 internal constant ETA_INPUT_LENGTH = 0xc0; // W1, W2, W3 = 6 * 0x20 bytes\\n\\n    // We need to hash 41 field elements when generating the NU challenge\\n    // w1, w2, w3, w4, s, z, z_lookup, q1, q2, q3, q4, qm, qc, qarith (14)\\n    // qsort, qelliptic, qaux, sigma1, sigma2, sigma, sigma4, (7)\\n    // table1, table2, table3, table4, tabletype, id1, id2, id3, id4, (9)\\n    // w1_omega, w2_omega, w3_omega, w4_omega, s_omega, z_omega, z_lookup_omega, (7)\\n    // table1_omega, table2_omega, table3_omega, table4_omega (4)\\n    uint256 internal constant NU_INPUT_LENGTH = 0x520; // 0x520 = 41 * 0x20\\n\\n    // There are ELEVEN G1 group elements added into the transcript in the `beta` round, that we need to skip over\\n    // W1, W2, W3, W4, S, Z, Z_LOOKUP, T1, T2, T3, T4\\n    uint256 internal constant NU_CALLDATA_SKIP_LENGTH = 0x2c0; // 11 * 0x40 = 0x2c0\\n\\n    uint256 internal constant NEGATIVE_INVERSE_OF_2_MODULO_P =\\n        0x183227397098d014dc2822db40c0ac2e9419f4243cdcb848a1f0fac9f8000000;\\n    uint256 internal constant LIMB_SIZE = 0x100000000000000000; // 2<<68\\n    uint256 internal constant SUBLIMB_SHIFT = 0x4000; // 2<<14\\n\\n    // y^2 = x^3 + ax + b\\n    // for Grumpkin, a = 0 and b = -17. We use b in a custom gate relation that evaluates elliptic curve arithmetic\\n    uint256 internal constant GRUMPKIN_CURVE_B_PARAMETER_NEGATED = 17;\\n    error PUBLIC_INPUT_COUNT_INVALID(uint256 expected, uint256 actual);\\n    error PUBLIC_INPUT_INVALID_BN128_G1_POINT();\\n    error PUBLIC_INPUT_GE_P();\\n    error MOD_EXP_FAILURE();\\n    error EC_SCALAR_MUL_FAILURE();\\n    error PROOF_FAILURE();\\n\\n    function getVerificationKeyHash() public pure virtual returns (bytes32);\\n\\n    function loadVerificationKey(uint256 _vk, uint256 _omegaInverseLoc) internal pure virtual;\\n\\n    /**\\n     * @notice Verify a Ultra Plonk proof\\n     * @param _proof - The serialized proof\\n     * @param _publicInputs - An array of the public inputs\\n     * @return True if proof is valid, reverts otherwise\\n     */\\n    function verify(bytes calldata _proof, bytes32[] calldata _publicInputs) public view returns (bool) {\\n        loadVerificationKey(N_LOC, OMEGA_INVERSE_LOC);\\n\\n        uint256 requiredPublicInputCount;\\n        assembly {\\n            requiredPublicInputCount := mload(NUM_INPUTS_LOC)\\n        }\\n        if (requiredPublicInputCount != _publicInputs.length) {\\n            revert PUBLIC_INPUT_COUNT_INVALID(requiredPublicInputCount, _publicInputs.length);\\n        }\\n\\n        assembly {\\n            let q := 21888242871839275222246405745257275088696311157297823662689037894645226208583 // EC group order\\n            let p := 21888242871839275222246405745257275088548364400416034343698204186575808495617 // Prime field order\\n\\n            /**\\n             * LOAD PROOF FROM CALLDATA\\n             */\\n            {\\n                let data_ptr := add(calldataload(0x04), 0x24)\\n\\n                mstore(W1_Y_LOC, mod(calldataload(data_ptr), q))\\n                mstore(W1_X_LOC, mod(calldataload(add(data_ptr, 0x20)), q))\\n\\n                mstore(W2_Y_LOC, mod(calldataload(add(data_ptr, 0x40)), q))\\n                mstore(W2_X_LOC, mod(calldataload(add(data_ptr, 0x60)), q))\\n\\n                mstore(W3_Y_LOC, mod(calldataload(add(data_ptr, 0x80)), q))\\n                mstore(W3_X_LOC, mod(calldataload(add(data_ptr, 0xa0)), q))\\n\\n                mstore(W4_Y_LOC, mod(calldataload(add(data_ptr, 0xc0)), q))\\n                mstore(W4_X_LOC, mod(calldataload(add(data_ptr, 0xe0)), q))\\n\\n                mstore(S_Y_LOC, mod(calldataload(add(data_ptr, 0x100)), q))\\n                mstore(S_X_LOC, mod(calldataload(add(data_ptr, 0x120)), q))\\n                mstore(Z_Y_LOC, mod(calldataload(add(data_ptr, 0x140)), q))\\n                mstore(Z_X_LOC, mod(calldataload(add(data_ptr, 0x160)), q))\\n                mstore(Z_LOOKUP_Y_LOC, mod(calldataload(add(data_ptr, 0x180)), q))\\n                mstore(Z_LOOKUP_X_LOC, mod(calldataload(add(data_ptr, 0x1a0)), q))\\n                mstore(T1_Y_LOC, mod(calldataload(add(data_ptr, 0x1c0)), q))\\n                mstore(T1_X_LOC, mod(calldataload(add(data_ptr, 0x1e0)), q))\\n\\n                mstore(T2_Y_LOC, mod(calldataload(add(data_ptr, 0x200)), q))\\n                mstore(T2_X_LOC, mod(calldataload(add(data_ptr, 0x220)), q))\\n\\n                mstore(T3_Y_LOC, mod(calldataload(add(data_ptr, 0x240)), q))\\n                mstore(T3_X_LOC, mod(calldataload(add(data_ptr, 0x260)), q))\\n\\n                mstore(T4_Y_LOC, mod(calldataload(add(data_ptr, 0x280)), q))\\n                mstore(T4_X_LOC, mod(calldataload(add(data_ptr, 0x2a0)), q))\\n\\n                mstore(W1_EVAL_LOC, mod(calldataload(add(data_ptr, 0x2c0)), p))\\n                mstore(W2_EVAL_LOC, mod(calldataload(add(data_ptr, 0x2e0)), p))\\n                mstore(W3_EVAL_LOC, mod(calldataload(add(data_ptr, 0x300)), p))\\n                mstore(W4_EVAL_LOC, mod(calldataload(add(data_ptr, 0x320)), p))\\n                mstore(S_EVAL_LOC, mod(calldataload(add(data_ptr, 0x340)), p))\\n                mstore(Z_EVAL_LOC, mod(calldataload(add(data_ptr, 0x360)), p))\\n                mstore(Z_LOOKUP_EVAL_LOC, mod(calldataload(add(data_ptr, 0x380)), p))\\n                mstore(Q1_EVAL_LOC, mod(calldataload(add(data_ptr, 0x3a0)), p))\\n                mstore(Q2_EVAL_LOC, mod(calldataload(add(data_ptr, 0x3c0)), p))\\n                mstore(Q3_EVAL_LOC, mod(calldataload(add(data_ptr, 0x3e0)), p))\\n                mstore(Q4_EVAL_LOC, mod(calldataload(add(data_ptr, 0x400)), p))\\n                mstore(QM_EVAL_LOC, mod(calldataload(add(data_ptr, 0x420)), p))\\n                mstore(QC_EVAL_LOC, mod(calldataload(add(data_ptr, 0x440)), p))\\n                mstore(QARITH_EVAL_LOC, mod(calldataload(add(data_ptr, 0x460)), p))\\n                mstore(QSORT_EVAL_LOC, mod(calldataload(add(data_ptr, 0x480)), p))\\n                mstore(QELLIPTIC_EVAL_LOC, mod(calldataload(add(data_ptr, 0x4a0)), p))\\n                mstore(QAUX_EVAL_LOC, mod(calldataload(add(data_ptr, 0x4c0)), p))\\n\\n                mstore(SIGMA1_EVAL_LOC, mod(calldataload(add(data_ptr, 0x4e0)), p))\\n                mstore(SIGMA2_EVAL_LOC, mod(calldataload(add(data_ptr, 0x500)), p))\\n\\n                mstore(SIGMA3_EVAL_LOC, mod(calldataload(add(data_ptr, 0x520)), p))\\n                mstore(SIGMA4_EVAL_LOC, mod(calldataload(add(data_ptr, 0x540)), p))\\n\\n                mstore(TABLE1_EVAL_LOC, mod(calldataload(add(data_ptr, 0x560)), p))\\n                mstore(TABLE2_EVAL_LOC, mod(calldataload(add(data_ptr, 0x580)), p))\\n                mstore(TABLE3_EVAL_LOC, mod(calldataload(add(data_ptr, 0x5a0)), p))\\n                mstore(TABLE4_EVAL_LOC, mod(calldataload(add(data_ptr, 0x5c0)), p))\\n                mstore(TABLE_TYPE_EVAL_LOC, mod(calldataload(add(data_ptr, 0x5e0)), p))\\n\\n                mstore(ID1_EVAL_LOC, mod(calldataload(add(data_ptr, 0x600)), p))\\n                mstore(ID2_EVAL_LOC, mod(calldataload(add(data_ptr, 0x620)), p))\\n                mstore(ID3_EVAL_LOC, mod(calldataload(add(data_ptr, 0x640)), p))\\n                mstore(ID4_EVAL_LOC, mod(calldataload(add(data_ptr, 0x660)), p))\\n\\n                mstore(W1_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x680)), p))\\n                mstore(W2_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x6a0)), p))\\n                mstore(W3_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x6c0)), p))\\n                mstore(W4_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x6e0)), p))\\n                mstore(S_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x700)), p))\\n\\n                mstore(Z_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x720)), p))\\n\\n                mstore(Z_LOOKUP_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x740)), p))\\n                mstore(TABLE1_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x760)), p))\\n                mstore(TABLE2_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x780)), p))\\n                mstore(TABLE3_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x7a0)), p))\\n                mstore(TABLE4_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x7c0)), p))\\n\\n                mstore(PI_Z_Y_LOC, mod(calldataload(add(data_ptr, 0x7e0)), q))\\n                mstore(PI_Z_X_LOC, mod(calldataload(add(data_ptr, 0x800)), q))\\n\\n                mstore(PI_Z_OMEGA_Y_LOC, mod(calldataload(add(data_ptr, 0x820)), q))\\n                mstore(PI_Z_OMEGA_X_LOC, mod(calldataload(add(data_ptr, 0x840)), q))\\n            }\\n\\n            /**\\n             * LOAD RECURSIVE PROOF INTO MEMORY\\n             */\\n            {\\n                if mload(CONTAINS_RECURSIVE_PROOF_LOC) {\\n                    let public_inputs_ptr := add(calldataload(0x24), 0x24)\\n                    let index_counter := add(shl(5, mload(RECURSIVE_PROOF_PUBLIC_INPUT_INDICES_LOC)), public_inputs_ptr)\\n\\n                    let x0 := calldataload(index_counter)\\n                    x0 := add(x0, shl(68, calldataload(add(index_counter, 0x20))))\\n                    x0 := add(x0, shl(136, calldataload(add(index_counter, 0x40))))\\n                    x0 := add(x0, shl(204, calldataload(add(index_counter, 0x60))))\\n                    let y0 := calldataload(add(index_counter, 0x80))\\n                    y0 := add(y0, shl(68, calldataload(add(index_counter, 0xa0))))\\n                    y0 := add(y0, shl(136, calldataload(add(index_counter, 0xc0))))\\n                    y0 := add(y0, shl(204, calldataload(add(index_counter, 0xe0))))\\n                    let x1 := calldataload(add(index_counter, 0x100))\\n                    x1 := add(x1, shl(68, calldataload(add(index_counter, 0x120))))\\n                    x1 := add(x1, shl(136, calldataload(add(index_counter, 0x140))))\\n                    x1 := add(x1, shl(204, calldataload(add(index_counter, 0x160))))\\n                    let y1 := calldataload(add(index_counter, 0x180))\\n                    y1 := add(y1, shl(68, calldataload(add(index_counter, 0x1a0))))\\n                    y1 := add(y1, shl(136, calldataload(add(index_counter, 0x1c0))))\\n                    y1 := add(y1, shl(204, calldataload(add(index_counter, 0x1e0))))\\n                    mstore(RECURSIVE_P1_X_LOC, x0)\\n                    mstore(RECURSIVE_P1_Y_LOC, y0)\\n                    mstore(RECURSIVE_P2_X_LOC, x1)\\n                    mstore(RECURSIVE_P2_Y_LOC, y1)\\n\\n                    // validate these are valid bn128 G1 points\\n                    if iszero(and(and(lt(x0, q), lt(x1, q)), and(lt(y0, q), lt(y1, q)))) {\\n                        mstore(0x00, PUBLIC_INPUT_INVALID_BN128_G1_POINT_SELECTOR)\\n                        revert(0x00, 0x04)\\n                    }\\n                }\\n            }\\n\\n            {\\n                /**\\n                 * Generate initial challenge\\n                 */\\n                mstore(0x00, shl(224, mload(N_LOC)))\\n                mstore(0x04, shl(224, mload(NUM_INPUTS_LOC)))\\n                let challenge := keccak256(0x00, 0x08)\\n\\n                /**\\n                 * Generate eta challenge\\n                 */\\n                mstore(PUBLIC_INPUTS_HASH_LOCATION, challenge)\\n                // The public input location is stored at 0x24, we then add 0x24 to skip selector and the length of public inputs\\n                let public_inputs_start := add(calldataload(0x24), 0x24)\\n                // copy the public inputs over\\n                let public_input_size := mul(mload(NUM_INPUTS_LOC), 0x20)\\n                calldatacopy(add(PUBLIC_INPUTS_HASH_LOCATION, 0x20), public_inputs_start, public_input_size)\\n\\n                // copy W1, W2, W3 into challenge. Each point is 0x40 bytes, so load 0xc0 = 3 * 0x40 bytes (ETA input length)\\n                let w_start := add(calldataload(0x04), 0x24)\\n                calldatacopy(add(add(PUBLIC_INPUTS_HASH_LOCATION, 0x20), public_input_size), w_start, ETA_INPUT_LENGTH)\\n\\n                // Challenge is the old challenge + public inputs + W1, W2, W3 (0x20 + public_input_size + 0xc0)\\n                let challenge_bytes_size := add(0x20, add(public_input_size, ETA_INPUT_LENGTH))\\n\\n                challenge := keccak256(PUBLIC_INPUTS_HASH_LOCATION, challenge_bytes_size)\\n                {\\n                    let eta := mod(challenge, p)\\n                    mstore(C_ETA_LOC, eta)\\n                    mstore(C_ETA_SQR_LOC, mulmod(eta, eta, p))\\n                    mstore(C_ETA_CUBE_LOC, mulmod(mload(C_ETA_SQR_LOC), eta, p))\\n                }\\n\\n                /**\\n                 * Generate beta challenge\\n                 */\\n                mstore(0x00, challenge)\\n                mstore(0x20, mload(W4_Y_LOC))\\n                mstore(0x40, mload(W4_X_LOC))\\n                mstore(0x60, mload(S_Y_LOC))\\n                mstore(0x80, mload(S_X_LOC))\\n                challenge := keccak256(0x00, 0xa0)\\n                mstore(C_BETA_LOC, mod(challenge, p))\\n\\n                /**\\n                 * Generate gamma challenge\\n                 */\\n                mstore(0x00, challenge)\\n                mstore8(0x20, 0x01)\\n                challenge := keccak256(0x00, 0x21)\\n                mstore(C_GAMMA_LOC, mod(challenge, p))\\n\\n                /**\\n                 * Generate alpha challenge\\n                 */\\n                mstore(0x00, challenge)\\n                mstore(0x20, mload(Z_Y_LOC))\\n                mstore(0x40, mload(Z_X_LOC))\\n                mstore(0x60, mload(Z_LOOKUP_Y_LOC))\\n                mstore(0x80, mload(Z_LOOKUP_X_LOC))\\n                challenge := keccak256(0x00, 0xa0)\\n                mstore(C_ALPHA_LOC, mod(challenge, p))\\n\\n                /**\\n                 * Compute and store some powers of alpha for future computations\\n                 */\\n                let alpha := mload(C_ALPHA_LOC)\\n                mstore(C_ALPHA_SQR_LOC, mulmod(alpha, alpha, p))\\n                mstore(C_ALPHA_CUBE_LOC, mulmod(mload(C_ALPHA_SQR_LOC), alpha, p))\\n                mstore(C_ALPHA_QUAD_LOC, mulmod(mload(C_ALPHA_CUBE_LOC), alpha, p))\\n                mstore(C_ALPHA_BASE_LOC, alpha)\\n\\n                /**\\n                 * Generate zeta challenge\\n                 */\\n                mstore(0x00, challenge)\\n                mstore(0x20, mload(T1_Y_LOC))\\n                mstore(0x40, mload(T1_X_LOC))\\n                mstore(0x60, mload(T2_Y_LOC))\\n                mstore(0x80, mload(T2_X_LOC))\\n                mstore(0xa0, mload(T3_Y_LOC))\\n                mstore(0xc0, mload(T3_X_LOC))\\n                mstore(0xe0, mload(T4_Y_LOC))\\n                mstore(0x100, mload(T4_X_LOC))\\n\\n                challenge := keccak256(0x00, 0x120)\\n\\n                mstore(C_ZETA_LOC, mod(challenge, p))\\n                mstore(C_CURRENT_LOC, challenge)\\n            }\\n\\n            /**\\n             * EVALUATE FIELD OPERATIONS\\n             */\\n\\n            /**\\n             * COMPUTE PUBLIC INPUT DELTA\\n             * \\u0394PI = \\u220f\\u1d62\\u2208\\u2113(w\\u1d62 + \\u03b2 \\u03c3(i) + \\u03b3) / \\u220f\\u1d62\\u2208\\u2113(w\\u1d62 + \\u03b2 \\u03c3'(i) + \\u03b3)\\n             */\\n            {\\n                let beta := mload(C_BETA_LOC) // \\u03b2\\n                let gamma := mload(C_GAMMA_LOC) // \\u03b3\\n                let work_root := mload(OMEGA_LOC) // \\u03c9\\n                let numerator_value := 1\\n                let denominator_value := 1\\n\\n                let p_clone := p // move p to the front of the stack\\n                let valid_inputs := true\\n\\n                // Load the starting point of the public inputs (jump over the selector and the length of public inputs [0x24])\\n                let public_inputs_ptr := add(calldataload(0x24), 0x24)\\n\\n                // endpoint_ptr = public_inputs_ptr + num_inputs * 0x20. // every public input is 0x20 bytes\\n                let endpoint_ptr := add(public_inputs_ptr, mul(mload(NUM_INPUTS_LOC), 0x20))\\n\\n                // root_1 = \\u03b2 * 0x05\\n                let root_1 := mulmod(beta, 0x05, p_clone) // k1.\\u03b2\\n                // root_2 = \\u03b2 * 0x0c\\n                let root_2 := mulmod(beta, 0x0c, p_clone)\\n                // @note 0x05 + 0x07 == 0x0c == external coset generator\\n\\n                for {} lt(public_inputs_ptr, endpoint_ptr) { public_inputs_ptr := add(public_inputs_ptr, 0x20) } {\\n                    /**\\n                     * input = public_input[i]\\n                     * valid_inputs &= input < p\\n                     * temp = input + gamma\\n                     * numerator_value *= (\\u03b2.\\u03c3(i) + w\\u1d62 + \\u03b3)  // \\u03c3(i) = 0x05.\\u03c9\\u2071\\n                     * denominator_value *= (\\u03b2.\\u03c3'(i) + w\\u1d62 + \\u03b3) // \\u03c3'(i) = 0x0c.\\u03c9\\u2071\\n                     * root_1 *= \\u03c9\\n                     * root_2 *= \\u03c9\\n                     */\\n\\n                    let input := calldataload(public_inputs_ptr)\\n                    valid_inputs := and(valid_inputs, lt(input, p_clone))\\n                    let temp := addmod(input, gamma, p_clone)\\n\\n                    numerator_value := mulmod(numerator_value, add(root_1, temp), p_clone)\\n                    denominator_value := mulmod(denominator_value, add(root_2, temp), p_clone)\\n\\n                    root_1 := mulmod(root_1, work_root, p_clone)\\n                    root_2 := mulmod(root_2, work_root, p_clone)\\n                }\\n\\n                // Revert if not all public inputs are field elements (i.e. < p)\\n                if iszero(valid_inputs) {\\n                    mstore(0x00, PUBLIC_INPUT_GE_P_SELECTOR)\\n                    revert(0x00, 0x04)\\n                }\\n\\n                mstore(DELTA_NUMERATOR_LOC, numerator_value)\\n                mstore(DELTA_DENOMINATOR_LOC, denominator_value)\\n            }\\n\\n            /**\\n             * Compute Plookup delta factor [\\u03b3(1 + \\u03b2)]^{n-k}\\n             * k = num roots cut out of Z_H = 4\\n             */\\n            {\\n                let delta_base := mulmod(mload(C_GAMMA_LOC), addmod(mload(C_BETA_LOC), 1, p), p)\\n                let delta_numerator := delta_base\\n                {\\n                    let exponent := mload(N_LOC)\\n                    let count := 1\\n                    for {} lt(count, exponent) { count := add(count, count) } {\\n                        delta_numerator := mulmod(delta_numerator, delta_numerator, p)\\n                    }\\n                }\\n                mstore(PLOOKUP_DELTA_NUMERATOR_LOC, delta_numerator)\\n\\n                let delta_denominator := mulmod(delta_base, delta_base, p)\\n                delta_denominator := mulmod(delta_denominator, delta_denominator, p)\\n                mstore(PLOOKUP_DELTA_DENOMINATOR_LOC, delta_denominator)\\n            }\\n            /**\\n             * Compute lagrange poly and vanishing poly fractions\\n             */\\n            {\\n                /**\\n                 * vanishing_numerator = zeta\\n                 * ZETA_POW_N = zeta^n\\n                 * vanishing_numerator -= 1\\n                 * accumulating_root = omega_inverse\\n                 * work_root = p - accumulating_root\\n                 * domain_inverse = domain_inverse\\n                 * vanishing_denominator = zeta + work_root\\n                 * work_root *= accumulating_root\\n                 * vanishing_denominator *= (zeta + work_root)\\n                 * work_root *= accumulating_root\\n                 * vanishing_denominator *= (zeta + work_root)\\n                 * vanishing_denominator *= (zeta + (zeta + accumulating_root))\\n                 * work_root = omega\\n                 * lagrange_numerator = vanishing_numerator * domain_inverse\\n                 * l_start_denominator = zeta - 1\\n                 * accumulating_root = work_root^2\\n                 * l_end_denominator = accumulating_root^2 * work_root * zeta - 1\\n                 * Note: l_end_denominator term contains a term \\\\omega^5 to cut out 5 roots of unity from vanishing poly\\n                 */\\n\\n                let zeta := mload(C_ZETA_LOC)\\n\\n                // compute zeta^n, where n is a power of 2\\n                let vanishing_numerator := zeta\\n                {\\n                    // pow_small\\n                    let exponent := mload(N_LOC)\\n                    let count := 1\\n                    for {} lt(count, exponent) { count := add(count, count) } {\\n                        vanishing_numerator := mulmod(vanishing_numerator, vanishing_numerator, p)\\n                    }\\n                }\\n                mstore(ZETA_POW_N_LOC, vanishing_numerator)\\n                vanishing_numerator := addmod(vanishing_numerator, sub(p, 1), p)\\n\\n                let accumulating_root := mload(OMEGA_INVERSE_LOC)\\n                let work_root := sub(p, accumulating_root)\\n                let domain_inverse := mload(DOMAIN_INVERSE_LOC)\\n\\n                let vanishing_denominator := addmod(zeta, work_root, p)\\n                work_root := mulmod(work_root, accumulating_root, p)\\n                vanishing_denominator := mulmod(vanishing_denominator, addmod(zeta, work_root, p), p)\\n                work_root := mulmod(work_root, accumulating_root, p)\\n                vanishing_denominator := mulmod(vanishing_denominator, addmod(zeta, work_root, p), p)\\n                vanishing_denominator :=\\n                    mulmod(vanishing_denominator, addmod(zeta, mulmod(work_root, accumulating_root, p), p), p)\\n\\n                work_root := mload(OMEGA_LOC)\\n\\n                let lagrange_numerator := mulmod(vanishing_numerator, domain_inverse, p)\\n                let l_start_denominator := addmod(zeta, sub(p, 1), p)\\n\\n                accumulating_root := mulmod(work_root, work_root, p)\\n\\n                let l_end_denominator :=\\n                    addmod(\\n                        mulmod(mulmod(mulmod(accumulating_root, accumulating_root, p), work_root, p), zeta, p), sub(p, 1), p\\n                    )\\n\\n                /**\\n                 * Compute inversions using Montgomery's batch inversion trick\\n                 */\\n                let accumulator := mload(DELTA_DENOMINATOR_LOC)\\n                let t0 := accumulator\\n                accumulator := mulmod(accumulator, vanishing_denominator, p)\\n                let t1 := accumulator\\n                accumulator := mulmod(accumulator, vanishing_numerator, p)\\n                let t2 := accumulator\\n                accumulator := mulmod(accumulator, l_start_denominator, p)\\n                let t3 := accumulator\\n                accumulator := mulmod(accumulator, mload(PLOOKUP_DELTA_DENOMINATOR_LOC), p)\\n                let t4 := accumulator\\n                {\\n                    mstore(0, 0x20)\\n                    mstore(0x20, 0x20)\\n                    mstore(0x40, 0x20)\\n                    mstore(0x60, mulmod(accumulator, l_end_denominator, p))\\n                    mstore(0x80, sub(p, 2))\\n                    mstore(0xa0, p)\\n                    if iszero(staticcall(gas(), 0x05, 0x00, 0xc0, 0x00, 0x20)) {\\n                        mstore(0x0, MOD_EXP_FAILURE_SELECTOR)\\n                        revert(0x00, 0x04)\\n                    }\\n                    accumulator := mload(0x00)\\n                }\\n\\n                t4 := mulmod(accumulator, t4, p)\\n                accumulator := mulmod(accumulator, l_end_denominator, p)\\n\\n                t3 := mulmod(accumulator, t3, p)\\n                accumulator := mulmod(accumulator, mload(PLOOKUP_DELTA_DENOMINATOR_LOC), p)\\n\\n                t2 := mulmod(accumulator, t2, p)\\n                accumulator := mulmod(accumulator, l_start_denominator, p)\\n\\n                t1 := mulmod(accumulator, t1, p)\\n                accumulator := mulmod(accumulator, vanishing_numerator, p)\\n\\n                t0 := mulmod(accumulator, t0, p)\\n                accumulator := mulmod(accumulator, vanishing_denominator, p)\\n\\n                accumulator := mulmod(mulmod(accumulator, accumulator, p), mload(DELTA_DENOMINATOR_LOC), p)\\n\\n                mstore(PUBLIC_INPUT_DELTA_LOC, mulmod(mload(DELTA_NUMERATOR_LOC), accumulator, p))\\n                mstore(ZERO_POLY_LOC, mulmod(vanishing_numerator, t0, p))\\n                mstore(ZERO_POLY_INVERSE_LOC, mulmod(vanishing_denominator, t1, p))\\n                mstore(L_START_LOC, mulmod(lagrange_numerator, t2, p))\\n                mstore(PLOOKUP_DELTA_LOC, mulmod(mload(PLOOKUP_DELTA_NUMERATOR_LOC), t3, p))\\n                mstore(L_END_LOC, mulmod(lagrange_numerator, t4, p))\\n            }\\n\\n            /**\\n             * UltraPlonk Widget Ordering:\\n             *\\n             * 1. Permutation widget\\n             * 2. Plookup widget\\n             * 3. Arithmetic widget\\n             * 4. Fixed base widget (?)\\n             * 5. GenPermSort widget\\n             * 6. Elliptic widget\\n             * 7. Auxiliary widget\\n             */\\n\\n            /**\\n             * COMPUTE PERMUTATION WIDGET EVALUATION\\n             */\\n            {\\n                let alpha := mload(C_ALPHA_LOC)\\n                let beta := mload(C_BETA_LOC)\\n                let gamma := mload(C_GAMMA_LOC)\\n\\n                /**\\n                 * t1 = (W1 + gamma + beta * ID1) * (W2 + gamma + beta * ID2)\\n                 * t2 = (W3 + gamma + beta * ID3) * (W4 + gamma + beta * ID4)\\n                 * result = alpha_base * z_eval * t1 * t2\\n                 * t1 = (W1 + gamma + beta * sigma_1_eval) * (W2 + gamma + beta * sigma_2_eval)\\n                 * t2 = (W2 + gamma + beta * sigma_3_eval) * (W3 + gamma + beta * sigma_4_eval)\\n                 * result -= (alpha_base * z_omega_eval * t1 * t2)\\n                 */\\n                let t1 :=\\n                    mulmod(\\n                        add(add(mload(W1_EVAL_LOC), gamma), mulmod(beta, mload(ID1_EVAL_LOC), p)),\\n                        add(add(mload(W2_EVAL_LOC), gamma), mulmod(beta, mload(ID2_EVAL_LOC), p)),\\n                        p\\n                    )\\n                let t2 :=\\n                    mulmod(\\n                        add(add(mload(W3_EVAL_LOC), gamma), mulmod(beta, mload(ID3_EVAL_LOC), p)),\\n                        add(add(mload(W4_EVAL_LOC), gamma), mulmod(beta, mload(ID4_EVAL_LOC), p)),\\n                        p\\n                    )\\n                let result := mulmod(mload(C_ALPHA_BASE_LOC), mulmod(mload(Z_EVAL_LOC), mulmod(t1, t2, p), p), p)\\n                t1 :=\\n                    mulmod(\\n                        add(add(mload(W1_EVAL_LOC), gamma), mulmod(beta, mload(SIGMA1_EVAL_LOC), p)),\\n                        add(add(mload(W2_EVAL_LOC), gamma), mulmod(beta, mload(SIGMA2_EVAL_LOC), p)),\\n                        p\\n                    )\\n                t2 :=\\n                    mulmod(\\n                        add(add(mload(W3_EVAL_LOC), gamma), mulmod(beta, mload(SIGMA3_EVAL_LOC), p)),\\n                        add(add(mload(W4_EVAL_LOC), gamma), mulmod(beta, mload(SIGMA4_EVAL_LOC), p)),\\n                        p\\n                    )\\n                result :=\\n                    addmod(\\n                        result,\\n                        sub(p, mulmod(mload(C_ALPHA_BASE_LOC), mulmod(mload(Z_OMEGA_EVAL_LOC), mulmod(t1, t2, p), p), p)),\\n                        p\\n                    )\\n\\n                /**\\n                 * alpha_base *= alpha\\n                 * result += alpha_base . (L_{n-k}(\\u0293) . (z(\\u0293.\\u03c9) - \\u2206_{PI}))\\n                 * alpha_base *= alpha\\n                 * result += alpha_base . (L_1(\\u0293)(Z(\\u0293) - 1))\\n                 * alpha_Base *= alpha\\n                 */\\n                mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_LOC), p))\\n                result :=\\n                    addmod(\\n                        result,\\n                        mulmod(\\n                            mload(C_ALPHA_BASE_LOC),\\n                            mulmod(\\n                                mload(L_END_LOC),\\n                                addmod(mload(Z_OMEGA_EVAL_LOC), sub(p, mload(PUBLIC_INPUT_DELTA_LOC)), p),\\n                                p\\n                            ),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_LOC), p))\\n                mstore(\\n                    PERMUTATION_IDENTITY,\\n                    addmod(\\n                        result,\\n                        mulmod(\\n                            mload(C_ALPHA_BASE_LOC),\\n                            mulmod(mload(L_START_LOC), addmod(mload(Z_EVAL_LOC), sub(p, 1), p), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                )\\n                mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_LOC), p))\\n            }\\n\\n            /**\\n             * COMPUTE PLOOKUP WIDGET EVALUATION\\n             */\\n            {\\n                /**\\n                 * Goal: f = (w1(z) + q2.w1(z\\u03c9)) + \\u03b7(w2(z) + qm.w2(z\\u03c9)) + \\u03b7\\u00b2(w3(z) + qc.w_3(z\\u03c9)) + q3(z).\\u03b7\\u00b3\\n                 * f = \\u03b7.q3(z)\\n                 * f += (w3(z) + qc.w_3(z\\u03c9))\\n                 * f *= \\u03b7\\n                 * f += (w2(z) + qm.w2(z\\u03c9))\\n                 * f *= \\u03b7\\n                 * f += (w1(z) + q2.w1(z\\u03c9))\\n                 */\\n                let f := mulmod(mload(C_ETA_LOC), mload(Q3_EVAL_LOC), p)\\n                f :=\\n                    addmod(f, addmod(mload(W3_EVAL_LOC), mulmod(mload(QC_EVAL_LOC), mload(W3_OMEGA_EVAL_LOC), p), p), p)\\n                f := mulmod(f, mload(C_ETA_LOC), p)\\n                f :=\\n                    addmod(f, addmod(mload(W2_EVAL_LOC), mulmod(mload(QM_EVAL_LOC), mload(W2_OMEGA_EVAL_LOC), p), p), p)\\n                f := mulmod(f, mload(C_ETA_LOC), p)\\n                f :=\\n                    addmod(f, addmod(mload(W1_EVAL_LOC), mulmod(mload(Q2_EVAL_LOC), mload(W1_OMEGA_EVAL_LOC), p), p), p)\\n\\n                // t(z) = table4(z).\\u03b7\\u00b3 + table3(z).\\u03b7\\u00b2 + table2(z).\\u03b7 + table1(z)\\n                let t :=\\n                    addmod(\\n                        addmod(\\n                            addmod(\\n                                mulmod(mload(TABLE4_EVAL_LOC), mload(C_ETA_CUBE_LOC), p),\\n                                mulmod(mload(TABLE3_EVAL_LOC), mload(C_ETA_SQR_LOC), p),\\n                                p\\n                            ),\\n                            mulmod(mload(TABLE2_EVAL_LOC), mload(C_ETA_LOC), p),\\n                            p\\n                        ),\\n                        mload(TABLE1_EVAL_LOC),\\n                        p\\n                    )\\n\\n                // t(zw) = table4(zw).\\u03b7\\u00b3 + table3(zw).\\u03b7\\u00b2 + table2(zw).\\u03b7 + table1(zw)\\n                let t_omega :=\\n                    addmod(\\n                        addmod(\\n                            addmod(\\n                                mulmod(mload(TABLE4_OMEGA_EVAL_LOC), mload(C_ETA_CUBE_LOC), p),\\n                                mulmod(mload(TABLE3_OMEGA_EVAL_LOC), mload(C_ETA_SQR_LOC), p),\\n                                p\\n                            ),\\n                            mulmod(mload(TABLE2_OMEGA_EVAL_LOC), mload(C_ETA_LOC), p),\\n                            p\\n                        ),\\n                        mload(TABLE1_OMEGA_EVAL_LOC),\\n                        p\\n                    )\\n\\n                /**\\n                 * Goal: numerator = (TABLE_TYPE_EVAL * f(z) + \\u03b3) * (t(z) + \\u03b2t(z\\u03c9) + \\u03b3(\\u03b2 + 1)) * (\\u03b2 + 1)\\n                 * gamma_beta_constant = \\u03b3(\\u03b2 + 1)\\n                 * numerator = f * TABLE_TYPE_EVAL + gamma\\n                 * temp0 = t(z) + t(z\\u03c9) * \\u03b2 + gamma_beta_constant\\n                 * numerator *= temp0\\n                 * numerator *= (\\u03b2 + 1)\\n                 * temp0 = alpha * l_1\\n                 * numerator += temp0\\n                 * numerator *= z_lookup(z)\\n                 * numerator -= temp0\\n                 */\\n                let gamma_beta_constant := mulmod(mload(C_GAMMA_LOC), addmod(mload(C_BETA_LOC), 1, p), p)\\n                let numerator := addmod(mulmod(f, mload(TABLE_TYPE_EVAL_LOC), p), mload(C_GAMMA_LOC), p)\\n                let temp0 := addmod(addmod(t, mulmod(t_omega, mload(C_BETA_LOC), p), p), gamma_beta_constant, p)\\n                numerator := mulmod(numerator, temp0, p)\\n                numerator := mulmod(numerator, addmod(mload(C_BETA_LOC), 1, p), p)\\n                temp0 := mulmod(mload(C_ALPHA_LOC), mload(L_START_LOC), p)\\n                numerator := addmod(numerator, temp0, p)\\n                numerator := mulmod(numerator, mload(Z_LOOKUP_EVAL_LOC), p)\\n                numerator := addmod(numerator, sub(p, temp0), p)\\n\\n                /**\\n                 * Goal: denominator = z_lookup(z\\u03c9)*[s(z) + \\u03b2s(z\\u03c9) + \\u03b3(1 + \\u03b2)] - [z_lookup(z\\u03c9) - [\\u03b3(1 + \\u03b2)]^{n-k}]*\\u03b1\\u00b2L_end(z)\\n                 * note: delta_factor = [\\u03b3(1 + \\u03b2)]^{n-k}\\n                 * denominator = s(z) + \\u03b2s(z\\u03c9) + \\u03b3(\\u03b2 + 1)\\n                 * temp1 = \\u03b1\\u00b2L_end(z)\\n                 * denominator -= temp1\\n                 * denominator *= z_lookup(z\\u03c9)\\n                 * denominator += temp1 * delta_factor\\n                 * PLOOKUP_IDENTITY = (numerator - denominator).alpha_base\\n                 * alpha_base *= alpha^3\\n                 */\\n                let denominator :=\\n                    addmod(\\n                        addmod(mload(S_EVAL_LOC), mulmod(mload(S_OMEGA_EVAL_LOC), mload(C_BETA_LOC), p), p),\\n                        gamma_beta_constant,\\n                        p\\n                    )\\n                let temp1 := mulmod(mload(C_ALPHA_SQR_LOC), mload(L_END_LOC), p)\\n                denominator := addmod(denominator, sub(p, temp1), p)\\n                denominator := mulmod(denominator, mload(Z_LOOKUP_OMEGA_EVAL_LOC), p)\\n                denominator := addmod(denominator, mulmod(temp1, mload(PLOOKUP_DELTA_LOC), p), p)\\n\\n                mstore(PLOOKUP_IDENTITY, mulmod(addmod(numerator, sub(p, denominator), p), mload(C_ALPHA_BASE_LOC), p))\\n\\n                // update alpha\\n                mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_CUBE_LOC), p))\\n            }\\n\\n            /**\\n             * COMPUTE ARITHMETIC WIDGET EVALUATION\\n             */\\n            {\\n                /**\\n                 * The basic arithmetic gate identity in standard plonk is as follows.\\n                 * (w_1 . w_2 . q_m) + (w_1 . q_1) + (w_2 . q_2) + (w_3 . q_3) + (w_4 . q_4) + q_c = 0\\n                 * However, for Ultraplonk, we extend this to support \\\"passing\\\" wires between rows (shown without alpha scaling below):\\n                 * q_arith * ( ( (-1/2) * (q_arith - 3) * q_m * w_1 * w_2 + q_1 * w_1 + q_2 * w_2 + q_3 * w_3 + q_4 * w_4 + q_c ) +\\n                 * (q_arith - 1)*( \\u03b1 * (q_arith - 2) * (w_1 + w_4 - w_1_omega + q_m) + w_4_omega) ) = 0\\n                 *\\n                 * This formula results in several cases depending on q_arith:\\n                 * 1. q_arith == 0: Arithmetic gate is completely disabled\\n                 *\\n                 * 2. q_arith == 1: Everything in the minigate on the right is disabled. The equation is just a standard plonk equation\\n                 * with extra wires: q_m * w_1 * w_2 + q_1 * w_1 + q_2 * w_2 + q_3 * w_3 + q_4 * w_4 + q_c = 0\\n                 *\\n                 * 3. q_arith == 2: The (w_1 + w_4 - ...) term is disabled. THe equation is:\\n                 * (1/2) * q_m * w_1 * w_2 + q_1 * w_1 + q_2 * w_2 + q_3 * w_3 + q_4 * w_4 + q_c + w_4_omega = 0\\n                 * It allows defining w_4 at next index (w_4_omega) in terms of current wire values\\n                 *\\n                 * 4. q_arith == 3: The product of w_1 and w_2 is disabled, but a mini addition gate is enabled. \\u03b1 allows us to split\\n                 * the equation into two:\\n                 *\\n                 * q_1 * w_1 + q_2 * w_2 + q_3 * w_3 + q_4 * w_4 + q_c + 2 * w_4_omega = 0\\n                 * and\\n                 * w_1 + w_4 - w_1_omega + q_m = 0  (we are reusing q_m here)\\n                 *\\n                 * 5. q_arith > 3: The product of w_1 and w_2 is scaled by (q_arith - 3), while the w_4_omega term is scaled by (q_arith - 1).\\n                 * The equation can be split into two:\\n                 *\\n                 * (q_arith - 3)* q_m * w_1 * w_ 2 + q_1 * w_1 + q_2 * w_2 + q_3 * w_3 + q_4 * w_4 + q_c + (q_arith - 1) * w_4_omega = 0\\n                 * and\\n                 * w_1 + w_4 - w_1_omega + q_m = 0\\n                 *\\n                 * The problem that q_m is used both in both equations can be dealt with by appropriately changing selector values at\\n                 * the next gate. Then we can treat (q_arith - 1) as a simulated q_6 selector and scale q_m to handle (q_arith - 3) at\\n                 * product.\\n                 */\\n\\n                let w1q1 := mulmod(mload(W1_EVAL_LOC), mload(Q1_EVAL_LOC), p)\\n                let w2q2 := mulmod(mload(W2_EVAL_LOC), mload(Q2_EVAL_LOC), p)\\n                let w3q3 := mulmod(mload(W3_EVAL_LOC), mload(Q3_EVAL_LOC), p)\\n                let w4q3 := mulmod(mload(W4_EVAL_LOC), mload(Q4_EVAL_LOC), p)\\n\\n                // @todo - Add a explicit test that hits QARITH == 3\\n                // w1w2qm := (w_1 . w_2 . q_m . (QARITH_EVAL_LOC - 3)) / 2\\n                let w1w2qm :=\\n                    mulmod(\\n                        mulmod(\\n                            mulmod(mulmod(mload(W1_EVAL_LOC), mload(W2_EVAL_LOC), p), mload(QM_EVAL_LOC), p),\\n                            addmod(mload(QARITH_EVAL_LOC), sub(p, 3), p),\\n                            p\\n                        ),\\n                        NEGATIVE_INVERSE_OF_2_MODULO_P,\\n                        p\\n                    )\\n\\n                // (w_1 . w_2 . q_m . (q_arith - 3)) / -2) + (w_1 . q_1) + (w_2 . q_2) + (w_3 . q_3) + (w_4 . q_4) + q_c\\n                let identity :=\\n                    addmod(\\n                        mload(QC_EVAL_LOC), addmod(w4q3, addmod(w3q3, addmod(w2q2, addmod(w1q1, w1w2qm, p), p), p), p), p\\n                    )\\n\\n                // if q_arith == 3 we evaluate an additional mini addition gate (on top of the regular one), where:\\n                // w_1 + w_4 - w_1_omega + q_m = 0\\n                // we use this gate to save an addition gate when adding or subtracting non-native field elements\\n                // \\u03b1 * (q_arith - 2) * (w_1 + w_4 - w_1_omega + q_m)\\n                let extra_small_addition_gate_identity :=\\n                    mulmod(\\n                        mload(C_ALPHA_LOC),\\n                        mulmod(\\n                            addmod(mload(QARITH_EVAL_LOC), sub(p, 2), p),\\n                            addmod(\\n                                mload(QM_EVAL_LOC),\\n                                addmod(\\n                                    sub(p, mload(W1_OMEGA_EVAL_LOC)), addmod(mload(W1_EVAL_LOC), mload(W4_EVAL_LOC), p), p\\n                                ),\\n                                p\\n                            ),\\n                            p\\n                        ),\\n                        p\\n                    )\\n\\n                // if q_arith == 2 OR q_arith == 3 we add the 4th wire of the NEXT gate into the arithmetic identity\\n                // N.B. if q_arith > 2, this wire value will be scaled by (q_arith - 1) relative to the other gate wires!\\n                // alpha_base * q_arith * (identity + (q_arith - 1) * (w_4_omega + extra_small_addition_gate_identity))\\n                mstore(\\n                    ARITHMETIC_IDENTITY,\\n                    mulmod(\\n                        mload(C_ALPHA_BASE_LOC),\\n                        mulmod(\\n                            mload(QARITH_EVAL_LOC),\\n                            addmod(\\n                                identity,\\n                                mulmod(\\n                                    addmod(mload(QARITH_EVAL_LOC), sub(p, 1), p),\\n                                    addmod(mload(W4_OMEGA_EVAL_LOC), extra_small_addition_gate_identity, p),\\n                                    p\\n                                ),\\n                                p\\n                            ),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                )\\n\\n                // update alpha\\n                mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_SQR_LOC), p))\\n            }\\n\\n            /**\\n             * COMPUTE GENPERMSORT WIDGET EVALUATION\\n             */\\n            {\\n                /**\\n                 * D1 = (w2 - w1)\\n                 * D2 = (w3 - w2)\\n                 * D3 = (w4 - w3)\\n                 * D4 = (w1_omega - w4)\\n                 *\\n                 * \\u03b1_a = alpha_base\\n                 * \\u03b1_b = alpha_base * \\u03b1\\n                 * \\u03b1_c = alpha_base * \\u03b1^2\\n                 * \\u03b1_d = alpha_base * \\u03b1^3\\n                 *\\n                 * range_accumulator = (\\n                 *   D1(D1 - 1)(D1 - 2)(D1 - 3).\\u03b1_a +\\n                 *   D2(D2 - 1)(D2 - 2)(D2 - 3).\\u03b1_b +\\n                 *   D3(D3 - 1)(D3 - 2)(D3 - 3).\\u03b1_c +\\n                 *   D4(D4 - 1)(D4 - 2)(D4 - 3).\\u03b1_d +\\n                 * ) . q_sort\\n                 */\\n                let minus_two := sub(p, 2)\\n                let minus_three := sub(p, 3)\\n                let d1 := addmod(mload(W2_EVAL_LOC), sub(p, mload(W1_EVAL_LOC)), p)\\n                let d2 := addmod(mload(W3_EVAL_LOC), sub(p, mload(W2_EVAL_LOC)), p)\\n                let d3 := addmod(mload(W4_EVAL_LOC), sub(p, mload(W3_EVAL_LOC)), p)\\n                let d4 := addmod(mload(W1_OMEGA_EVAL_LOC), sub(p, mload(W4_EVAL_LOC)), p)\\n\\n                let range_accumulator :=\\n                    mulmod(\\n                        mulmod(\\n                            mulmod(addmod(mulmod(d1, d1, p), sub(p, d1), p), addmod(d1, minus_two, p), p),\\n                            addmod(d1, minus_three, p),\\n                            p\\n                        ),\\n                        mload(C_ALPHA_BASE_LOC),\\n                        p\\n                    )\\n                range_accumulator :=\\n                    addmod(\\n                        range_accumulator,\\n                        mulmod(\\n                            mulmod(\\n                                mulmod(addmod(mulmod(d2, d2, p), sub(p, d2), p), addmod(d2, minus_two, p), p),\\n                                addmod(d2, minus_three, p),\\n                                p\\n                            ),\\n                            mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                range_accumulator :=\\n                    addmod(\\n                        range_accumulator,\\n                        mulmod(\\n                            mulmod(\\n                                mulmod(addmod(mulmod(d3, d3, p), sub(p, d3), p), addmod(d3, minus_two, p), p),\\n                                addmod(d3, minus_three, p),\\n                                p\\n                            ),\\n                            mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_SQR_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                range_accumulator :=\\n                    addmod(\\n                        range_accumulator,\\n                        mulmod(\\n                            mulmod(\\n                                mulmod(addmod(mulmod(d4, d4, p), sub(p, d4), p), addmod(d4, minus_two, p), p),\\n                                addmod(d4, minus_three, p),\\n                                p\\n                            ),\\n                            mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_CUBE_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                range_accumulator := mulmod(range_accumulator, mload(QSORT_EVAL_LOC), p)\\n\\n                mstore(SORT_IDENTITY, range_accumulator)\\n\\n                // update alpha\\n                mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_QUAD_LOC), p))\\n            }\\n\\n            /**\\n             * COMPUTE ELLIPTIC WIDGET EVALUATION\\n             */\\n            {\\n                /**\\n                 * endo_term = (-x_2) * x_1 * (x_3 * 2 + x_1) * q_beta\\n                 * endo_sqr_term = x_2^2\\n                 * endo_sqr_term *= (x_3 - x_1)\\n                 * endo_sqr_term *= q_beta^2\\n                 * leftovers = x_2^2\\n                 * leftovers *= x_2\\n                 * leftovers += x_1^2 * (x_3 + x_1) @follow-up Invalid comment in BB widget\\n                 * leftovers -= (y_2^2 + y_1^2)\\n                 * sign_term = y_2 * y_1\\n                 * sign_term += sign_term\\n                 * sign_term *= q_sign\\n                 */\\n                // q_elliptic * (x3 + x2 + x1)(x2 - x1)(x2 - x1) - y2^2 - y1^2 + 2(y2y1)*q_sign = 0\\n                let x_diff := addmod(mload(X2_EVAL_LOC), sub(p, mload(X1_EVAL_LOC)), p)\\n                let y2_sqr := mulmod(mload(Y2_EVAL_LOC), mload(Y2_EVAL_LOC), p)\\n                let y1_sqr := mulmod(mload(Y1_EVAL_LOC), mload(Y1_EVAL_LOC), p)\\n                let y1y2 := mulmod(mulmod(mload(Y1_EVAL_LOC), mload(Y2_EVAL_LOC), p), mload(QSIGN_LOC), p)\\n\\n                let x_add_identity :=\\n                    addmod(\\n                        mulmod(\\n                            addmod(mload(X3_EVAL_LOC), addmod(mload(X2_EVAL_LOC), mload(X1_EVAL_LOC), p), p),\\n                            mulmod(x_diff, x_diff, p),\\n                            p\\n                        ),\\n                        addmod(\\n                            sub(\\n                                p,\\n                                addmod(y2_sqr, y1_sqr, p)\\n                            ),\\n                            addmod(y1y2, y1y2, p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                x_add_identity :=\\n                    mulmod(\\n                        mulmod(\\n                            x_add_identity,\\n                            addmod(\\n                                1,\\n                                sub(p, mload(QM_EVAL_LOC)),\\n                                p\\n                            ),\\n                            p\\n                        ),\\n                        mload(C_ALPHA_BASE_LOC),\\n                        p\\n                    )\\n\\n                // q_elliptic * (x3 + x2 + x1)(x2 - x1)(x2 - x1) - y2^2 - y1^2 + 2(y2y1)*q_sign = 0\\n                let y1_plus_y3 := addmod(\\n                    mload(Y1_EVAL_LOC),\\n                    mload(Y3_EVAL_LOC),\\n                    p\\n                )\\n                let y_diff := addmod(mulmod(mload(Y2_EVAL_LOC), mload(QSIGN_LOC), p), sub(p, mload(Y1_EVAL_LOC)), p)\\n                let y_add_identity :=\\n                    addmod(\\n                        mulmod(y1_plus_y3, x_diff, p),\\n                        mulmod(addmod(mload(X3_EVAL_LOC), sub(p, mload(X1_EVAL_LOC)), p), y_diff, p),\\n                        p\\n                    )\\n                y_add_identity :=\\n                    mulmod(\\n                        mulmod(y_add_identity, addmod(1, sub(p, mload(QM_EVAL_LOC)), p), p),\\n                        mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_LOC), p),\\n                        p\\n                    )\\n\\n                // ELLIPTIC_IDENTITY = (x_identity + y_identity) * Q_ELLIPTIC_EVAL\\n                mstore(\\n                    ELLIPTIC_IDENTITY, mulmod(addmod(x_add_identity, y_add_identity, p), mload(QELLIPTIC_EVAL_LOC), p)\\n                )\\n            }\\n            {\\n                /**\\n                 * x_pow_4 = (y_1_sqr - curve_b) * x_1;\\n                 * y_1_sqr_mul_4 = y_1_sqr + y_1_sqr;\\n                 * y_1_sqr_mul_4 += y_1_sqr_mul_4;\\n                 * x_1_pow_4_mul_9 = x_pow_4;\\n                 * x_1_pow_4_mul_9 += x_1_pow_4_mul_9;\\n                 * x_1_pow_4_mul_9 += x_1_pow_4_mul_9;\\n                 * x_1_pow_4_mul_9 += x_1_pow_4_mul_9;\\n                 * x_1_pow_4_mul_9 += x_pow_4;\\n                 * x_1_sqr_mul_3 = x_1_sqr + x_1_sqr + x_1_sqr;\\n                 * x_double_identity = (x_3 + x_1 + x_1) * y_1_sqr_mul_4 - x_1_pow_4_mul_9;\\n                 * y_double_identity = x_1_sqr_mul_3 * (x_1 - x_3) - (y_1 + y_1) * (y_1 + y_3);\\n                 */\\n                // (x3 + x1 + x1) (4y1*y1) - 9 * x1 * x1 * x1 * x1 = 0\\n                let x1_sqr := mulmod(mload(X1_EVAL_LOC), mload(X1_EVAL_LOC), p)\\n                let y1_sqr := mulmod(mload(Y1_EVAL_LOC), mload(Y1_EVAL_LOC), p)\\n                let x_pow_4 := mulmod(addmod(y1_sqr, GRUMPKIN_CURVE_B_PARAMETER_NEGATED, p), mload(X1_EVAL_LOC), p)\\n                let y1_sqr_mul_4 := mulmod(y1_sqr, 4, p)\\n                let x1_pow_4_mul_9 := mulmod(x_pow_4, 9, p)\\n                let x1_sqr_mul_3 := mulmod(x1_sqr, 3, p)\\n                let x_double_identity :=\\n                    addmod(\\n                        mulmod(\\n                            addmod(mload(X3_EVAL_LOC), addmod(mload(X1_EVAL_LOC), mload(X1_EVAL_LOC), p), p),\\n                            y1_sqr_mul_4,\\n                            p\\n                        ),\\n                        sub(p, x1_pow_4_mul_9),\\n                        p\\n                    )\\n                // (y1 + y1) (2y1) - (3 * x1 * x1)(x1 - x3) = 0\\n                let y_double_identity :=\\n                    addmod(\\n                        mulmod(x1_sqr_mul_3, addmod(mload(X1_EVAL_LOC), sub(p, mload(X3_EVAL_LOC)), p), p),\\n                        sub(\\n                            p,\\n                            mulmod(\\n                                addmod(mload(Y1_EVAL_LOC), mload(Y1_EVAL_LOC), p),\\n                                addmod(mload(Y1_EVAL_LOC), mload(Y3_EVAL_LOC), p),\\n                                p\\n                            )\\n                        ),\\n                        p\\n                    )\\n                x_double_identity := mulmod(x_double_identity, mload(C_ALPHA_BASE_LOC), p)\\n                y_double_identity :=\\n                    mulmod(y_double_identity, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_LOC), p), p)\\n                x_double_identity := mulmod(x_double_identity, mload(QM_EVAL_LOC), p)\\n                y_double_identity := mulmod(y_double_identity, mload(QM_EVAL_LOC), p)\\n                // ELLIPTIC_IDENTITY += (x_double_identity + y_double_identity) * Q_DOUBLE_EVAL\\n                mstore(\\n                    ELLIPTIC_IDENTITY,\\n                    addmod(\\n                        mload(ELLIPTIC_IDENTITY),\\n                        mulmod(addmod(x_double_identity, y_double_identity, p), mload(QELLIPTIC_EVAL_LOC), p),\\n                        p\\n                    )\\n                )\\n\\n                // update alpha\\n                mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_QUAD_LOC), p))\\n            }\\n\\n            /**\\n             * COMPUTE AUXILIARY WIDGET EVALUATION\\n             */\\n            {\\n                {\\n                    /**\\n                     * Non native field arithmetic gate 2\\n                     *             _                                                                               _\\n                     *            /   _                   _                               _       14                \\\\\\n                     * q_2 . q_4 |   (w_1 . w_2) + (w_1 . w_2) + (w_1 . w_4 + w_2 . w_3 - w_3) . 2    - w_3 - w_4   |\\n                     *            \\\\_                                                                               _/\\n                     *\\n                     * limb_subproduct = w_1 . w_2_omega + w_1_omega . w_2\\n                     * non_native_field_gate_2 = w_1 * w_4 + w_4 * w_3 - w_3_omega\\n                     * non_native_field_gate_2 = non_native_field_gate_2 * limb_size\\n                     * non_native_field_gate_2 -= w_4_omega\\n                     * non_native_field_gate_2 += limb_subproduct\\n                     * non_native_field_gate_2 *= q_4\\n                     * limb_subproduct *= limb_size\\n                     * limb_subproduct += w_1_omega * w_2_omega\\n                     * non_native_field_gate_1 = (limb_subproduct + w_3 + w_4) * q_3\\n                     * non_native_field_gate_3 = (limb_subproduct + w_4 - (w_3_omega + w_4_omega)) * q_m\\n                     * non_native_field_identity = (non_native_field_gate_1 + non_native_field_gate_2 + non_native_field_gate_3) * q_2\\n                     */\\n\\n                    let limb_subproduct :=\\n                        addmod(\\n                            mulmod(mload(W1_EVAL_LOC), mload(W2_OMEGA_EVAL_LOC), p),\\n                            mulmod(mload(W1_OMEGA_EVAL_LOC), mload(W2_EVAL_LOC), p),\\n                            p\\n                        )\\n\\n                    let non_native_field_gate_2 :=\\n                        addmod(\\n                            addmod(\\n                                mulmod(mload(W1_EVAL_LOC), mload(W4_EVAL_LOC), p),\\n                                mulmod(mload(W2_EVAL_LOC), mload(W3_EVAL_LOC), p),\\n                                p\\n                            ),\\n                            sub(p, mload(W3_OMEGA_EVAL_LOC)),\\n                            p\\n                        )\\n                    non_native_field_gate_2 := mulmod(non_native_field_gate_2, LIMB_SIZE, p)\\n                    non_native_field_gate_2 := addmod(non_native_field_gate_2, sub(p, mload(W4_OMEGA_EVAL_LOC)), p)\\n                    non_native_field_gate_2 := addmod(non_native_field_gate_2, limb_subproduct, p)\\n                    non_native_field_gate_2 := mulmod(non_native_field_gate_2, mload(Q4_EVAL_LOC), p)\\n                    limb_subproduct := mulmod(limb_subproduct, LIMB_SIZE, p)\\n                    limb_subproduct :=\\n                        addmod(limb_subproduct, mulmod(mload(W1_OMEGA_EVAL_LOC), mload(W2_OMEGA_EVAL_LOC), p), p)\\n                    let non_native_field_gate_1 :=\\n                        mulmod(\\n                            addmod(limb_subproduct, sub(p, addmod(mload(W3_EVAL_LOC), mload(W4_EVAL_LOC), p)), p),\\n                            mload(Q3_EVAL_LOC),\\n                            p\\n                        )\\n                    let non_native_field_gate_3 :=\\n                        mulmod(\\n                            addmod(\\n                                addmod(limb_subproduct, mload(W4_EVAL_LOC), p),\\n                                sub(p, addmod(mload(W3_OMEGA_EVAL_LOC), mload(W4_OMEGA_EVAL_LOC), p)),\\n                                p\\n                            ),\\n                            mload(QM_EVAL_LOC),\\n                            p\\n                        )\\n                    let non_native_field_identity :=\\n                        mulmod(\\n                            addmod(addmod(non_native_field_gate_1, non_native_field_gate_2, p), non_native_field_gate_3, p),\\n                            mload(Q2_EVAL_LOC),\\n                            p\\n                        )\\n\\n                    mstore(AUX_NON_NATIVE_FIELD_EVALUATION, non_native_field_identity)\\n                }\\n\\n                {\\n                    /**\\n                     * limb_accumulator_1 = w_2_omega;\\n                     * limb_accumulator_1 *= SUBLIMB_SHIFT;\\n                     * limb_accumulator_1 += w_1_omega;\\n                     * limb_accumulator_1 *= SUBLIMB_SHIFT;\\n                     * limb_accumulator_1 += w_3;\\n                     * limb_accumulator_1 *= SUBLIMB_SHIFT;\\n                     * limb_accumulator_1 += w_2;\\n                     * limb_accumulator_1 *= SUBLIMB_SHIFT;\\n                     * limb_accumulator_1 += w_1;\\n                     * limb_accumulator_1 -= w_4;\\n                     * limb_accumulator_1 *= q_4;\\n                     */\\n                    let limb_accumulator_1 := mulmod(mload(W2_OMEGA_EVAL_LOC), SUBLIMB_SHIFT, p)\\n                    limb_accumulator_1 := addmod(limb_accumulator_1, mload(W1_OMEGA_EVAL_LOC), p)\\n                    limb_accumulator_1 := mulmod(limb_accumulator_1, SUBLIMB_SHIFT, p)\\n                    limb_accumulator_1 := addmod(limb_accumulator_1, mload(W3_EVAL_LOC), p)\\n                    limb_accumulator_1 := mulmod(limb_accumulator_1, SUBLIMB_SHIFT, p)\\n                    limb_accumulator_1 := addmod(limb_accumulator_1, mload(W2_EVAL_LOC), p)\\n                    limb_accumulator_1 := mulmod(limb_accumulator_1, SUBLIMB_SHIFT, p)\\n                    limb_accumulator_1 := addmod(limb_accumulator_1, mload(W1_EVAL_LOC), p)\\n                    limb_accumulator_1 := addmod(limb_accumulator_1, sub(p, mload(W4_EVAL_LOC)), p)\\n                    limb_accumulator_1 := mulmod(limb_accumulator_1, mload(Q4_EVAL_LOC), p)\\n\\n                    /**\\n                     * limb_accumulator_2 = w_3_omega;\\n                     * limb_accumulator_2 *= SUBLIMB_SHIFT;\\n                     * limb_accumulator_2 += w_2_omega;\\n                     * limb_accumulator_2 *= SUBLIMB_SHIFT;\\n                     * limb_accumulator_2 += w_1_omega;\\n                     * limb_accumulator_2 *= SUBLIMB_SHIFT;\\n                     * limb_accumulator_2 += w_4;\\n                     * limb_accumulator_2 *= SUBLIMB_SHIFT;\\n                     * limb_accumulator_2 += w_3;\\n                     * limb_accumulator_2 -= w_4_omega;\\n                     * limb_accumulator_2 *= q_m;\\n                     */\\n                    let limb_accumulator_2 := mulmod(mload(W3_OMEGA_EVAL_LOC), SUBLIMB_SHIFT, p)\\n                    limb_accumulator_2 := addmod(limb_accumulator_2, mload(W2_OMEGA_EVAL_LOC), p)\\n                    limb_accumulator_2 := mulmod(limb_accumulator_2, SUBLIMB_SHIFT, p)\\n                    limb_accumulator_2 := addmod(limb_accumulator_2, mload(W1_OMEGA_EVAL_LOC), p)\\n                    limb_accumulator_2 := mulmod(limb_accumulator_2, SUBLIMB_SHIFT, p)\\n                    limb_accumulator_2 := addmod(limb_accumulator_2, mload(W4_EVAL_LOC), p)\\n                    limb_accumulator_2 := mulmod(limb_accumulator_2, SUBLIMB_SHIFT, p)\\n                    limb_accumulator_2 := addmod(limb_accumulator_2, mload(W3_EVAL_LOC), p)\\n                    limb_accumulator_2 := addmod(limb_accumulator_2, sub(p, mload(W4_OMEGA_EVAL_LOC)), p)\\n                    limb_accumulator_2 := mulmod(limb_accumulator_2, mload(QM_EVAL_LOC), p)\\n\\n                    mstore(\\n                        AUX_LIMB_ACCUMULATOR_EVALUATION,\\n                        mulmod(addmod(limb_accumulator_1, limb_accumulator_2, p), mload(Q3_EVAL_LOC), p)\\n                    )\\n                }\\n\\n                {\\n                    /**\\n                     * memory_record_check = w_3;\\n                     * memory_record_check *= eta;\\n                     * memory_record_check += w_2;\\n                     * memory_record_check *= eta;\\n                     * memory_record_check += w_1;\\n                     * memory_record_check *= eta;\\n                     * memory_record_check += q_c;\\n                     *\\n                     * partial_record_check = memory_record_check;\\n                     *\\n                     * memory_record_check -= w_4;\\n                     */\\n\\n                    let memory_record_check := mulmod(mload(W3_EVAL_LOC), mload(C_ETA_LOC), p)\\n                    memory_record_check := addmod(memory_record_check, mload(W2_EVAL_LOC), p)\\n                    memory_record_check := mulmod(memory_record_check, mload(C_ETA_LOC), p)\\n                    memory_record_check := addmod(memory_record_check, mload(W1_EVAL_LOC), p)\\n                    memory_record_check := mulmod(memory_record_check, mload(C_ETA_LOC), p)\\n                    memory_record_check := addmod(memory_record_check, mload(QC_EVAL_LOC), p)\\n\\n                    let partial_record_check := memory_record_check\\n                    memory_record_check := addmod(memory_record_check, sub(p, mload(W4_EVAL_LOC)), p)\\n\\n                    mstore(AUX_MEMORY_EVALUATION, memory_record_check)\\n\\n                    // index_delta = w_1_omega - w_1\\n                    let index_delta := addmod(mload(W1_OMEGA_EVAL_LOC), sub(p, mload(W1_EVAL_LOC)), p)\\n                    // record_delta = w_4_omega - w_4\\n                    let record_delta := addmod(mload(W4_OMEGA_EVAL_LOC), sub(p, mload(W4_EVAL_LOC)), p)\\n                    // index_is_monotonically_increasing = index_delta * (index_delta - 1)\\n                    let index_is_monotonically_increasing := mulmod(index_delta, addmod(index_delta, sub(p, 1), p), p)\\n\\n                    // adjacent_values_match_if_adjacent_indices_match = record_delta * (1 - index_delta)\\n                    let adjacent_values_match_if_adjacent_indices_match :=\\n                        mulmod(record_delta, addmod(1, sub(p, index_delta), p), p)\\n\\n                    // AUX_ROM_CONSISTENCY_EVALUATION = ((adjacent_values_match_if_adjacent_indices_match * alpha) + index_is_monotonically_increasing) * alpha + partial_record_check\\n                    mstore(\\n                        AUX_ROM_CONSISTENCY_EVALUATION,\\n                        addmod(\\n                            mulmod(\\n                                addmod(\\n                                    mulmod(adjacent_values_match_if_adjacent_indices_match, mload(C_ALPHA_LOC), p),\\n                                    index_is_monotonically_increasing,\\n                                    p\\n                                ),\\n                                mload(C_ALPHA_LOC),\\n                                p\\n                            ),\\n                            memory_record_check,\\n                            p\\n                        )\\n                    )\\n\\n                    {\\n                        /**\\n                         * next_gate_access_type = w_3_omega;\\n                         * next_gate_access_type *= eta;\\n                         * next_gate_access_type += w_2_omega;\\n                         * next_gate_access_type *= eta;\\n                         * next_gate_access_type += w_1_omega;\\n                         * next_gate_access_type *= eta;\\n                         * next_gate_access_type = w_4_omega - next_gate_access_type;\\n                         */\\n                        let next_gate_access_type := mulmod(mload(W3_OMEGA_EVAL_LOC), mload(C_ETA_LOC), p)\\n                        next_gate_access_type := addmod(next_gate_access_type, mload(W2_OMEGA_EVAL_LOC), p)\\n                        next_gate_access_type := mulmod(next_gate_access_type, mload(C_ETA_LOC), p)\\n                        next_gate_access_type := addmod(next_gate_access_type, mload(W1_OMEGA_EVAL_LOC), p)\\n                        next_gate_access_type := mulmod(next_gate_access_type, mload(C_ETA_LOC), p)\\n                        next_gate_access_type := addmod(mload(W4_OMEGA_EVAL_LOC), sub(p, next_gate_access_type), p)\\n\\n                        // value_delta = w_3_omega - w_3\\n                        let value_delta := addmod(mload(W3_OMEGA_EVAL_LOC), sub(p, mload(W3_EVAL_LOC)), p)\\n                        //  adjacent_values_match_if_adjacent_indices_match_and_next_access_is_a_read_operation = (1 - index_delta) * value_delta * (1 - next_gate_access_type);\\n\\n                        let adjacent_values_match_if_adjacent_indices_match_and_next_access_is_a_read_operation :=\\n                            mulmod(\\n                                addmod(1, sub(p, index_delta), p),\\n                                mulmod(value_delta, addmod(1, sub(p, next_gate_access_type), p), p),\\n                                p\\n                            )\\n\\n                        // AUX_RAM_CONSISTENCY_EVALUATION\\n\\n                        /**\\n                         * access_type = w_4 - partial_record_check\\n                         * access_check = access_type^2 - access_type\\n                         * next_gate_access_type_is_boolean = next_gate_access_type^2 - next_gate_access_type\\n                         * RAM_consistency_check_identity = adjacent_values_match_if_adjacent_indices_match_and_next_access_is_a_read_operation;\\n                         * RAM_consistency_check_identity *= alpha;\\n                         * RAM_consistency_check_identity += index_is_monotonically_increasing;\\n                         * RAM_consistency_check_identity *= alpha;\\n                         * RAM_consistency_check_identity += next_gate_access_type_is_boolean;\\n                         * RAM_consistency_check_identity *= alpha;\\n                         * RAM_consistency_check_identity += access_check;\\n                         */\\n\\n                        let access_type := addmod(mload(W4_EVAL_LOC), sub(p, partial_record_check), p)\\n                        let access_check := mulmod(access_type, addmod(access_type, sub(p, 1), p), p)\\n                        let next_gate_access_type_is_boolean :=\\n                            mulmod(next_gate_access_type, addmod(next_gate_access_type, sub(p, 1), p), p)\\n                        let RAM_cci :=\\n                            mulmod(\\n                                adjacent_values_match_if_adjacent_indices_match_and_next_access_is_a_read_operation,\\n                                mload(C_ALPHA_LOC),\\n                                p\\n                            )\\n                        RAM_cci := addmod(RAM_cci, index_is_monotonically_increasing, p)\\n                        RAM_cci := mulmod(RAM_cci, mload(C_ALPHA_LOC), p)\\n                        RAM_cci := addmod(RAM_cci, next_gate_access_type_is_boolean, p)\\n                        RAM_cci := mulmod(RAM_cci, mload(C_ALPHA_LOC), p)\\n                        RAM_cci := addmod(RAM_cci, access_check, p)\\n\\n                        mstore(AUX_RAM_CONSISTENCY_EVALUATION, RAM_cci)\\n                    }\\n\\n                    {\\n                        // timestamp_delta = w_2_omega - w_2\\n                        let timestamp_delta := addmod(mload(W2_OMEGA_EVAL_LOC), sub(p, mload(W2_EVAL_LOC)), p)\\n\\n                        // RAM_timestamp_check_identity = (1 - index_delta) * timestamp_delta - w_3\\n                        let RAM_timestamp_check_identity :=\\n                            addmod(\\n                                mulmod(timestamp_delta, addmod(1, sub(p, index_delta), p), p), sub(p, mload(W3_EVAL_LOC)), p\\n                            )\\n\\n                        /**\\n                         * memory_identity = ROM_consistency_check_identity * q_2;\\n                         * memory_identity += RAM_timestamp_check_identity * q_4;\\n                         * memory_identity += memory_record_check * q_m;\\n                         * memory_identity *= q_1;\\n                         * memory_identity += (RAM_consistency_check_identity * q_arith);\\n                         *\\n                         * auxiliary_identity = memory_identity + non_native_field_identity + limb_accumulator_identity;\\n                         * auxiliary_identity *= q_aux;\\n                         * auxiliary_identity *= alpha_base;\\n                         */\\n                        let memory_identity := mulmod(mload(AUX_ROM_CONSISTENCY_EVALUATION), mload(Q2_EVAL_LOC), p)\\n                        memory_identity :=\\n                            addmod(memory_identity, mulmod(RAM_timestamp_check_identity, mload(Q4_EVAL_LOC), p), p)\\n                        memory_identity :=\\n                            addmod(memory_identity, mulmod(mload(AUX_MEMORY_EVALUATION), mload(QM_EVAL_LOC), p), p)\\n                        memory_identity := mulmod(memory_identity, mload(Q1_EVAL_LOC), p)\\n                        memory_identity :=\\n                            addmod(\\n                                memory_identity, mulmod(mload(AUX_RAM_CONSISTENCY_EVALUATION), mload(QARITH_EVAL_LOC), p), p\\n                            )\\n\\n                        let auxiliary_identity := addmod(memory_identity, mload(AUX_NON_NATIVE_FIELD_EVALUATION), p)\\n                        auxiliary_identity := addmod(auxiliary_identity, mload(AUX_LIMB_ACCUMULATOR_EVALUATION), p)\\n                        auxiliary_identity := mulmod(auxiliary_identity, mload(QAUX_EVAL_LOC), p)\\n                        auxiliary_identity := mulmod(auxiliary_identity, mload(C_ALPHA_BASE_LOC), p)\\n\\n                        mstore(AUX_IDENTITY, auxiliary_identity)\\n\\n                        // update alpha\\n                        mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_CUBE_LOC), p))\\n                    }\\n                }\\n            }\\n\\n            {\\n                /**\\n                 * quotient = ARITHMETIC_IDENTITY\\n                 * quotient += PERMUTATION_IDENTITY\\n                 * quotient += PLOOKUP_IDENTITY\\n                 * quotient += SORT_IDENTITY\\n                 * quotient += ELLIPTIC_IDENTITY\\n                 * quotient += AUX_IDENTITY\\n                 * quotient *= ZERO_POLY_INVERSE\\n                 */\\n                mstore(\\n                    QUOTIENT_EVAL_LOC,\\n                    mulmod(\\n                        addmod(\\n                            addmod(\\n                                addmod(\\n                                    addmod(\\n                                        addmod(mload(PERMUTATION_IDENTITY), mload(PLOOKUP_IDENTITY), p),\\n                                        mload(ARITHMETIC_IDENTITY),\\n                                        p\\n                                    ),\\n                                    mload(SORT_IDENTITY),\\n                                    p\\n                                ),\\n                                mload(ELLIPTIC_IDENTITY),\\n                                p\\n                            ),\\n                            mload(AUX_IDENTITY),\\n                            p\\n                        ),\\n                        mload(ZERO_POLY_INVERSE_LOC),\\n                        p\\n                    )\\n                )\\n            }\\n\\n            /**\\n             * GENERATE NU AND SEPARATOR CHALLENGES\\n             */\\n            {\\n                let current_challenge := mload(C_CURRENT_LOC)\\n                // get a calldata pointer that points to the start of the data we want to copy\\n                let calldata_ptr := add(calldataload(0x04), 0x24)\\n\\n                calldata_ptr := add(calldata_ptr, NU_CALLDATA_SKIP_LENGTH)\\n\\n                mstore(NU_CHALLENGE_INPUT_LOC_A, current_challenge)\\n                mstore(NU_CHALLENGE_INPUT_LOC_B, mload(QUOTIENT_EVAL_LOC))\\n                calldatacopy(NU_CHALLENGE_INPUT_LOC_C, calldata_ptr, NU_INPUT_LENGTH)\\n\\n                // hash length = (0x20 + num field elements), we include the previous challenge in the hash\\n                let challenge := keccak256(NU_CHALLENGE_INPUT_LOC_A, add(NU_INPUT_LENGTH, 0x40))\\n\\n                mstore(C_V0_LOC, mod(challenge, p))\\n                // We need THIRTY-ONE independent nu challenges!\\n                mstore(0x00, challenge)\\n                mstore8(0x20, 0x01)\\n                mstore(C_V1_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x02)\\n                mstore(C_V2_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x03)\\n                mstore(C_V3_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x04)\\n                mstore(C_V4_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x05)\\n                mstore(C_V5_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x06)\\n                mstore(C_V6_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x07)\\n                mstore(C_V7_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x08)\\n                mstore(C_V8_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x09)\\n                mstore(C_V9_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x0a)\\n                mstore(C_V10_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x0b)\\n                mstore(C_V11_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x0c)\\n                mstore(C_V12_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x0d)\\n                mstore(C_V13_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x0e)\\n                mstore(C_V14_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x0f)\\n                mstore(C_V15_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x10)\\n                mstore(C_V16_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x11)\\n                mstore(C_V17_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x12)\\n                mstore(C_V18_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x13)\\n                mstore(C_V19_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x14)\\n                mstore(C_V20_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x15)\\n                mstore(C_V21_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x16)\\n                mstore(C_V22_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x17)\\n                mstore(C_V23_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x18)\\n                mstore(C_V24_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x19)\\n                mstore(C_V25_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x1a)\\n                mstore(C_V26_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x1b)\\n                mstore(C_V27_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x1c)\\n                mstore(C_V28_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x1d)\\n                mstore(C_V29_LOC, mod(keccak256(0x00, 0x21), p))\\n\\n                // @follow-up - Why are both v29 and v30 using appending 0x1d to the prior challenge and hashing, should it not change?\\n                mstore8(0x20, 0x1d)\\n                challenge := keccak256(0x00, 0x21)\\n                mstore(C_V30_LOC, mod(challenge, p))\\n\\n                // separator\\n                mstore(0x00, challenge)\\n                mstore(0x20, mload(PI_Z_Y_LOC))\\n                mstore(0x40, mload(PI_Z_X_LOC))\\n                mstore(0x60, mload(PI_Z_OMEGA_Y_LOC))\\n                mstore(0x80, mload(PI_Z_OMEGA_X_LOC))\\n\\n                mstore(C_U_LOC, mod(keccak256(0x00, 0xa0), p))\\n            }\\n\\n            let success := 0\\n            // VALIDATE T1\\n            {\\n                let x := mload(T1_X_LOC)\\n                let y := mload(T1_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))\\n                mstore(ACCUMULATOR_X_LOC, x)\\n                mstore(add(ACCUMULATOR_X_LOC, 0x20), y)\\n            }\\n            // VALIDATE T2\\n            {\\n                let x := mload(T2_X_LOC) // 0x1400\\n                let y := mload(T2_Y_LOC) // 0x1420\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(ZETA_POW_N_LOC))\\n            // accumulator_2 = [T2].zeta^n\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = [T1] + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE T3\\n            {\\n                let x := mload(T3_X_LOC)\\n                let y := mload(T3_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(mload(ZETA_POW_N_LOC), mload(ZETA_POW_N_LOC), p))\\n            // accumulator_2 = [T3].zeta^{2n}\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE T4\\n            {\\n                let x := mload(T4_X_LOC)\\n                let y := mload(T4_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(mulmod(mload(ZETA_POW_N_LOC), mload(ZETA_POW_N_LOC), p), mload(ZETA_POW_N_LOC), p))\\n            // accumulator_2 = [T4].zeta^{3n}\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE W1\\n            {\\n                let x := mload(W1_X_LOC)\\n                let y := mload(W1_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V0_LOC), p))\\n            // accumulator_2 = v0.(u + 1).[W1]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE W2\\n            {\\n                let x := mload(W2_X_LOC)\\n                let y := mload(W2_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V1_LOC), p))\\n            // accumulator_2 = v1.(u + 1).[W2]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE W3\\n            {\\n                let x := mload(W3_X_LOC)\\n                let y := mload(W3_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V2_LOC), p))\\n            // accumulator_2 = v2.(u + 1).[W3]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE W4\\n            {\\n                let x := mload(W4_X_LOC)\\n                let y := mload(W4_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V3_LOC), p))\\n            // accumulator_2 = v3.(u + 1).[W4]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE S\\n            {\\n                let x := mload(S_X_LOC)\\n                let y := mload(S_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V4_LOC), p))\\n            // accumulator_2 = v4.(u + 1).[S]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE Z\\n            {\\n                let x := mload(Z_X_LOC)\\n                let y := mload(Z_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V5_LOC), p))\\n            // accumulator_2 = v5.(u + 1).[Z]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE Z_LOOKUP\\n            {\\n                let x := mload(Z_LOOKUP_X_LOC)\\n                let y := mload(Z_LOOKUP_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V6_LOC), p))\\n            // accumulator_2 = v6.(u + 1).[Z_LOOKUP]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE Q1\\n            {\\n                let x := mload(Q1_X_LOC)\\n                let y := mload(Q1_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V7_LOC))\\n            // accumulator_2 = v7.[Q1]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE Q2\\n            {\\n                let x := mload(Q2_X_LOC)\\n                let y := mload(Q2_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V8_LOC))\\n            // accumulator_2 = v8.[Q2]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE Q3\\n            {\\n                let x := mload(Q3_X_LOC)\\n                let y := mload(Q3_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V9_LOC))\\n            // accumulator_2 = v9.[Q3]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE Q4\\n            {\\n                let x := mload(Q4_X_LOC)\\n                let y := mload(Q4_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V10_LOC))\\n            // accumulator_2 = v10.[Q4]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE QM\\n            {\\n                let x := mload(QM_X_LOC)\\n                let y := mload(QM_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V11_LOC))\\n            // accumulator_2 = v11.[Q;]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE QC\\n            {\\n                let x := mload(QC_X_LOC)\\n                let y := mload(QC_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V12_LOC))\\n            // accumulator_2 = v12.[QC]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE QARITH\\n            {\\n                let x := mload(QARITH_X_LOC)\\n                let y := mload(QARITH_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V13_LOC))\\n            // accumulator_2 = v13.[QARITH]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE QSORT\\n            {\\n                let x := mload(QSORT_X_LOC)\\n                let y := mload(QSORT_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V14_LOC))\\n            // accumulator_2 = v14.[QSORT]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE QELLIPTIC\\n            {\\n                let x := mload(QELLIPTIC_X_LOC)\\n                let y := mload(QELLIPTIC_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V15_LOC))\\n            // accumulator_2 = v15.[QELLIPTIC]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE QAUX\\n            {\\n                let x := mload(QAUX_X_LOC)\\n                let y := mload(QAUX_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V16_LOC))\\n            // accumulator_2 = v15.[Q_AUX]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE SIGMA1\\n            {\\n                let x := mload(SIGMA1_X_LOC)\\n                let y := mload(SIGMA1_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V17_LOC))\\n            // accumulator_2 = v17.[sigma1]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE SIGMA2\\n            {\\n                let x := mload(SIGMA2_X_LOC)\\n                let y := mload(SIGMA2_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V18_LOC))\\n            // accumulator_2 = v18.[sigma2]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE SIGMA3\\n            {\\n                let x := mload(SIGMA3_X_LOC)\\n                let y := mload(SIGMA3_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V19_LOC))\\n            // accumulator_2 = v19.[sigma3]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE SIGMA4\\n            {\\n                let x := mload(SIGMA4_X_LOC)\\n                let y := mload(SIGMA4_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V20_LOC))\\n            // accumulator_2 = v20.[sigma4]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE TABLE1\\n            {\\n                let x := mload(TABLE1_X_LOC)\\n                let y := mload(TABLE1_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V21_LOC), p))\\n            // accumulator_2 = u.[table1]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE TABLE2\\n            {\\n                let x := mload(TABLE2_X_LOC)\\n                let y := mload(TABLE2_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V22_LOC), p))\\n            // accumulator_2 = u.[table2]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE TABLE3\\n            {\\n                let x := mload(TABLE3_X_LOC)\\n                let y := mload(TABLE3_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V23_LOC), p))\\n            // accumulator_2 = u.[table3]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE TABLE4\\n            {\\n                let x := mload(TABLE4_X_LOC)\\n                let y := mload(TABLE4_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V24_LOC), p))\\n            // accumulator_2 = u.[table4]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE TABLE_TYPE\\n            {\\n                let x := mload(TABLE_TYPE_X_LOC)\\n                let y := mload(TABLE_TYPE_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V25_LOC))\\n            // accumulator_2 = v25.[TableType]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE ID1\\n            {\\n                let x := mload(ID1_X_LOC)\\n                let y := mload(ID1_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V26_LOC))\\n            // accumulator_2 = v26.[ID1]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE ID2\\n            {\\n                let x := mload(ID2_X_LOC)\\n                let y := mload(ID2_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V27_LOC))\\n            // accumulator_2 = v27.[ID2]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE ID3\\n            {\\n                let x := mload(ID3_X_LOC)\\n                let y := mload(ID3_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V28_LOC))\\n            // accumulator_2 = v28.[ID3]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE ID4\\n            {\\n                let x := mload(ID4_X_LOC)\\n                let y := mload(ID4_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V29_LOC))\\n            // accumulator_2 = v29.[ID4]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            /**\\n             * COMPUTE BATCH EVALUATION SCALAR MULTIPLIER\\n             */\\n            {\\n                /**\\n                 * batch_evaluation = v0 * (w_1_omega * u + w_1_eval)\\n                 * batch_evaluation += v1 * (w_2_omega * u + w_2_eval)\\n                 * batch_evaluation += v2 * (w_3_omega * u + w_3_eval)\\n                 * batch_evaluation += v3 * (w_4_omega * u + w_4_eval)\\n                 * batch_evaluation += v4 * (s_omega_eval * u + s_eval)\\n                 * batch_evaluation += v5 * (z_omega_eval * u + z_eval)\\n                 * batch_evaluation += v6 * (z_lookup_omega_eval * u + z_lookup_eval)\\n                 */\\n                let batch_evaluation :=\\n                    mulmod(\\n                        mload(C_V0_LOC),\\n                        addmod(mulmod(mload(W1_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(W1_EVAL_LOC), p),\\n                        p\\n                    )\\n                batch_evaluation :=\\n                    addmod(\\n                        batch_evaluation,\\n                        mulmod(\\n                            mload(C_V1_LOC),\\n                            addmod(mulmod(mload(W2_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(W2_EVAL_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                batch_evaluation :=\\n                    addmod(\\n                        batch_evaluation,\\n                        mulmod(\\n                            mload(C_V2_LOC),\\n                            addmod(mulmod(mload(W3_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(W3_EVAL_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                batch_evaluation :=\\n                    addmod(\\n                        batch_evaluation,\\n                        mulmod(\\n                            mload(C_V3_LOC),\\n                            addmod(mulmod(mload(W4_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(W4_EVAL_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                batch_evaluation :=\\n                    addmod(\\n                        batch_evaluation,\\n                        mulmod(\\n                            mload(C_V4_LOC),\\n                            addmod(mulmod(mload(S_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(S_EVAL_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                batch_evaluation :=\\n                    addmod(\\n                        batch_evaluation,\\n                        mulmod(\\n                            mload(C_V5_LOC),\\n                            addmod(mulmod(mload(Z_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(Z_EVAL_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                batch_evaluation :=\\n                    addmod(\\n                        batch_evaluation,\\n                        mulmod(\\n                            mload(C_V6_LOC),\\n                            addmod(mulmod(mload(Z_LOOKUP_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(Z_LOOKUP_EVAL_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n\\n                /**\\n                 * batch_evaluation += v7 * Q1_EVAL\\n                 * batch_evaluation += v8 * Q2_EVAL\\n                 * batch_evaluation += v9 * Q3_EVAL\\n                 * batch_evaluation += v10 * Q4_EVAL\\n                 * batch_evaluation += v11 * QM_EVAL\\n                 * batch_evaluation += v12 * QC_EVAL\\n                 * batch_evaluation += v13 * QARITH_EVAL\\n                 * batch_evaluation += v14 * QSORT_EVAL_LOC\\n                 * batch_evaluation += v15 * QELLIPTIC_EVAL_LOC\\n                 * batch_evaluation += v16 * QAUX_EVAL_LOC\\n                 * batch_evaluation += v17 * SIGMA1_EVAL_LOC\\n                 * batch_evaluation += v18 * SIGMA2_EVAL_LOC\\n                 * batch_evaluation += v19 * SIGMA3_EVAL_LOC\\n                 * batch_evaluation += v20 * SIGMA4_EVAL_LOC\\n                 */\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V7_LOC), mload(Q1_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V8_LOC), mload(Q2_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V9_LOC), mload(Q3_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V10_LOC), mload(Q4_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V11_LOC), mload(QM_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V12_LOC), mload(QC_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V13_LOC), mload(QARITH_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V14_LOC), mload(QSORT_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V15_LOC), mload(QELLIPTIC_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V16_LOC), mload(QAUX_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V17_LOC), mload(SIGMA1_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V18_LOC), mload(SIGMA2_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V19_LOC), mload(SIGMA3_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V20_LOC), mload(SIGMA4_EVAL_LOC), p), p)\\n\\n                /**\\n                 * batch_evaluation += v21 * (table1(zw) * u + table1(z))\\n                 * batch_evaluation += v22 * (table2(zw) * u + table2(z))\\n                 * batch_evaluation += v23 * (table3(zw) * u + table3(z))\\n                 * batch_evaluation += v24 * (table4(zw) * u + table4(z))\\n                 * batch_evaluation += v25 * table_type_eval\\n                 * batch_evaluation += v26 * id1_eval\\n                 * batch_evaluation += v27 * id2_eval\\n                 * batch_evaluation += v28 * id3_eval\\n                 * batch_evaluation += v29 * id4_eval\\n                 * batch_evaluation += quotient_eval\\n                 */\\n                batch_evaluation :=\\n                    addmod(\\n                        batch_evaluation,\\n                        mulmod(\\n                            mload(C_V21_LOC),\\n                            addmod(mulmod(mload(TABLE1_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(TABLE1_EVAL_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                batch_evaluation :=\\n                    addmod(\\n                        batch_evaluation,\\n                        mulmod(\\n                            mload(C_V22_LOC),\\n                            addmod(mulmod(mload(TABLE2_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(TABLE2_EVAL_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                batch_evaluation :=\\n                    addmod(\\n                        batch_evaluation,\\n                        mulmod(\\n                            mload(C_V23_LOC),\\n                            addmod(mulmod(mload(TABLE3_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(TABLE3_EVAL_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                batch_evaluation :=\\n                    addmod(\\n                        batch_evaluation,\\n                        mulmod(\\n                            mload(C_V24_LOC),\\n                            addmod(mulmod(mload(TABLE4_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(TABLE4_EVAL_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V25_LOC), mload(TABLE_TYPE_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V26_LOC), mload(ID1_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V27_LOC), mload(ID2_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V28_LOC), mload(ID3_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V29_LOC), mload(ID4_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mload(QUOTIENT_EVAL_LOC), p)\\n\\n                mstore(0x00, 0x01) // [1].x\\n                mstore(0x20, 0x02) // [1].y\\n                mstore(0x40, sub(p, batch_evaluation))\\n                // accumulator_2 = -[1].(batch_evaluation)\\n                success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n                // accumulator = accumulator + accumulator_2\\n                success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n                mstore(OPENING_COMMITMENT_SUCCESS_FLAG, success)\\n            }\\n\\n            /**\\n             * PERFORM PAIRING PREAMBLE\\n             */\\n            {\\n                let u := mload(C_U_LOC)\\n                let zeta := mload(C_ZETA_LOC)\\n                // VALIDATE PI_Z\\n                {\\n                    let x := mload(PI_Z_X_LOC)\\n                    let y := mload(PI_Z_Y_LOC)\\n                    let xx := mulmod(x, x, q)\\n                    // validate on curve\\n                    success := eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))\\n                    mstore(0x00, x)\\n                    mstore(0x20, y)\\n                }\\n                // compute zeta.[PI_Z] and add into accumulator\\n                mstore(0x40, zeta)\\n                success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n                // accumulator = accumulator + accumulator_2\\n                success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n                // VALIDATE PI_Z_OMEGA\\n                {\\n                    let x := mload(PI_Z_OMEGA_X_LOC)\\n                    let y := mload(PI_Z_OMEGA_Y_LOC)\\n                    let xx := mulmod(x, x, q)\\n                    // validate on curve\\n                    success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                    mstore(0x00, x)\\n                    mstore(0x20, y)\\n                }\\n                mstore(0x40, mulmod(mulmod(u, zeta, p), mload(OMEGA_LOC), p))\\n                // accumulator_2 = u.zeta.omega.[PI_Z_OMEGA]\\n                success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n                // PAIRING_RHS = accumulator + accumulator_2\\n                success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, PAIRING_RHS_X_LOC, 0x40))\\n\\n                mstore(0x00, mload(PI_Z_X_LOC))\\n                mstore(0x20, mload(PI_Z_Y_LOC))\\n                mstore(0x40, mload(PI_Z_OMEGA_X_LOC))\\n                mstore(0x60, mload(PI_Z_OMEGA_Y_LOC))\\n                mstore(0x80, u)\\n                success := and(success, staticcall(gas(), 7, 0x40, 0x60, 0x40, 0x40))\\n                // PAIRING_LHS = [PI_Z] + [PI_Z_OMEGA] * u\\n                success := and(success, staticcall(gas(), 6, 0x00, 0x80, PAIRING_LHS_X_LOC, 0x40))\\n                // negate lhs y-coordinate\\n                mstore(PAIRING_LHS_Y_LOC, sub(q, mload(PAIRING_LHS_Y_LOC)))\\n\\n                if mload(CONTAINS_RECURSIVE_PROOF_LOC) {\\n                    // VALIDATE RECURSIVE P1\\n                    {\\n                        let x := mload(RECURSIVE_P1_X_LOC)\\n                        let y := mload(RECURSIVE_P1_Y_LOC)\\n                        let xx := mulmod(x, x, q)\\n                        // validate on curve\\n                        success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                        mstore(0x00, x)\\n                        mstore(0x20, y)\\n                    }\\n\\n                    // compute u.u.[recursive_p1] and write into 0x60\\n                    mstore(0x40, mulmod(u, u, p))\\n                    success := and(success, staticcall(gas(), 7, 0x00, 0x60, 0x60, 0x40))\\n                    // VALIDATE RECURSIVE P2\\n                    {\\n                        let x := mload(RECURSIVE_P2_X_LOC)\\n                        let y := mload(RECURSIVE_P2_Y_LOC)\\n                        let xx := mulmod(x, x, q)\\n                        // validate on curve\\n                        success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                        mstore(0x00, x)\\n                        mstore(0x20, y)\\n                    }\\n                    // compute u.u.[recursive_p2] and write into 0x00\\n                    // 0x40 still contains u*u\\n                    success := and(success, staticcall(gas(), 7, 0x00, 0x60, 0x00, 0x40))\\n\\n                    // compute u.u.[recursiveP1] + rhs and write into rhs\\n                    mstore(0xa0, mload(PAIRING_RHS_X_LOC))\\n                    mstore(0xc0, mload(PAIRING_RHS_Y_LOC))\\n                    success := and(success, staticcall(gas(), 6, 0x60, 0x80, PAIRING_RHS_X_LOC, 0x40))\\n\\n                    // compute u.u.[recursiveP2] + lhs and write into lhs\\n                    mstore(0x40, mload(PAIRING_LHS_X_LOC))\\n                    mstore(0x60, mload(PAIRING_LHS_Y_LOC))\\n                    success := and(success, staticcall(gas(), 6, 0x00, 0x80, PAIRING_LHS_X_LOC, 0x40))\\n                }\\n\\n                if iszero(success) {\\n                    mstore(0x0, EC_SCALAR_MUL_FAILURE_SELECTOR)\\n                    revert(0x00, 0x04)\\n                }\\n                mstore(PAIRING_PREAMBLE_SUCCESS_FLAG, success)\\n            }\\n\\n            /**\\n             * PERFORM PAIRING\\n             */\\n            {\\n                // rhs paired with [1]_2\\n                // lhs paired with [x]_2\\n\\n                mstore(0x00, mload(PAIRING_RHS_X_LOC))\\n                mstore(0x20, mload(PAIRING_RHS_Y_LOC))\\n                mstore(0x40, 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2) // this is [1]_2\\n                mstore(0x60, 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed)\\n                mstore(0x80, 0x090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b)\\n                mstore(0xa0, 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa)\\n\\n                mstore(0xc0, mload(PAIRING_LHS_X_LOC))\\n                mstore(0xe0, mload(PAIRING_LHS_Y_LOC))\\n                mstore(0x100, mload(G2X_X0_LOC))\\n                mstore(0x120, mload(G2X_X1_LOC))\\n                mstore(0x140, mload(G2X_Y0_LOC))\\n                mstore(0x160, mload(G2X_Y1_LOC))\\n\\n                success := staticcall(gas(), 8, 0x00, 0x180, 0x00, 0x20)\\n                mstore(PAIRING_SUCCESS_FLAG, success)\\n                mstore(RESULT_FLAG, mload(0x00))\\n            }\\n            if iszero(\\n                and(\\n                    and(and(mload(PAIRING_SUCCESS_FLAG), mload(RESULT_FLAG)), mload(PAIRING_PREAMBLE_SUCCESS_FLAG)),\\n                    mload(OPENING_COMMITMENT_SUCCESS_FLAG)\\n                )\\n            ) {\\n                mstore(0x0, PROOF_FAILURE_SELECTOR)\\n                revert(0x00, 0x04)\\n            }\\n            {\\n                mstore(0x00, 0x01)\\n                return(0x00, 0x20) // Proof succeeded!\\n            }\\n        }\\n    }\\n}\\n\\ncontract UltraVerifier is BaseUltraVerifier {\\n    function getVerificationKeyHash() public pure override(BaseUltraVerifier) returns (bytes32) {\\n        return UltraVerificationKey.verificationKeyHash();\\n    }\\n\\n    function loadVerificationKey(uint256 vk, uint256 _omegaInverseLoc) internal pure virtual override(BaseUltraVerifier) {\\n        UltraVerificationKey.loadVerificationKey(vk, _omegaInverseLoc);\\n    }\\n}\\n\",\"keccak256\":\"0x9332012499af99e98b029379be212f1cf912bd10e63aae7c8c0aa4cb623fd3b3\",\"license\":\"Apache-2.0\"}},\"version\":1}",
  "storageLayout": {
    "storage": [
      {
        "astId": 1450,
        "contract": "src/VitalikSecret.sol:VitalikSecret",
        "label": "_owners",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_uint256,t_uint256)"
      },
      {
        "astId": 1454,
        "contract": "src/VitalikSecret.sol:VitalikSecret",
        "label": "_balances",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 1460,
        "contract": "src/VitalikSecret.sol:VitalikSecret",
        "label": "_operatorsForAll",
        "offset": 0,
        "slot": "2",
        "type": "t_mapping(t_address,t_mapping(t_address,t_bool))"
      },
      {
        "astId": 1464,
        "contract": "src/VitalikSecret.sol:VitalikSecret",
        "label": "_operators",
        "offset": 0,
        "slot": "3",
        "type": "t_mapping(t_uint256,t_address)"
      },
      {
        "astId": 3021,
        "contract": "src/VitalikSecret.sol:VitalikSecret",
        "label": "zecret",
        "offset": 0,
        "slot": "4",
        "type": "t_contract(UltraVerifier)4599"
      },
      {
        "astId": 3037,
        "contract": "src/VitalikSecret.sol:VitalikSecret",
        "label": "lowestNumberOfMoves",
        "offset": 0,
        "slot": "5",
        "type": "t_uint256"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_contract(UltraVerifier)4599": {
        "encoding": "inplace",
        "label": "contract UltraVerifier",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_address,t_mapping(t_address,t_bool))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(address => bool))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_bool)"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_uint256,t_address)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => address)",
        "numberOfBytes": "32",
        "value": "t_address"
      },
      "t_mapping(t_uint256,t_uint256)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  },
  "userdoc": {
    "errors": {
      "InvalidAddress(address)": [
        {
          "notice": "An invalid address is specified (for example: zero address)"
        }
      ],
      "NonExistentToken(uint256)": [
        {
          "notice": "The token does not exist"
        }
      ],
      "NonceOverflow()": [
        {
          "notice": "The Nonce overflowed, make a transfer to self to allow new nonces."
        }
      ],
      "NotAuthorized()": [
        {
          "notice": "Not authorized to perform this operation"
        }
      ],
      "NotOwner(address,address)": [
        {
          "notice": "The address from which the token is sent is not the current owner"
        }
      ],
      "TransferRejected()": [
        {
          "notice": "The Transfer was rejected by the destination"
        }
      ]
    },
    "events": {
      "Approval(address,address,uint256)": {
        "notice": "Triggered when a token is approved to be sent by another account  Note tat the approval get reset when a Transfer event for that same token is emitted."
      },
      "ApprovalForAll(address,address,bool)": {
        "notice": "Triggered when an account approve or disaprove another to transfer on its behalf"
      },
      "Transfer(address,address,uint256)": {
        "notice": "Triggered when a token is transferred"
      }
    },
    "kind": "user",
    "methods": {
      "approve(address,uint256)": {
        "notice": "Approve an operator to transfer a specific token on the senders behalf."
      },
      "balanceOf(address)": {
        "notice": "Get the number of tokens owned by an address."
      },
      "getApproved(uint256)": {
        "notice": "Get the approved operator for a specific token."
      },
      "isApprovedForAll(address,address)": {
        "notice": "Check if the sender approved the operator to transfer any of its tokens."
      },
      "name()": {
        "notice": "A descriptive name for a collection of NFTs in this contract"
      },
      "ownerAndLastTransferBlockNumberList(uint256[])": {
        "notice": "Get the list of owner of a token and the blockNumber of its last transfer, useful to voting mechanism."
      },
      "ownerAndLastTransferBlockNumberOf(uint256)": {
        "notice": "Get the owner of a token and the blockNumber of the last transfer, useful to voting mechanism."
      },
      "ownerOf(uint256)": {
        "notice": "Get the owner of a token."
      },
      "safeTransferFrom(address,address,uint256)": {
        "notice": "Transfer a token between 2 addresses letting the receiver know of the transfer."
      },
      "safeTransferFrom(address,address,uint256,bytes)": {
        "notice": "Transfer a token between 2 addresses letting the receiver knows of the transfer."
      },
      "setApprovalForAll(address,bool)": {
        "notice": "Set the approval for an operator to manage all the tokens of the sender."
      },
      "supportsInterface(bytes4)": {
        "notice": "Query if a contract implements an interface"
      },
      "symbol()": {
        "notice": "An abbreviated name for NFTs in this contract"
      },
      "tokenURI(uint256)": {
        "notice": "A distinct Uniform Resource Identifier (URI) for a given asset."
      },
      "transferFrom(address,address,uint256)": {
        "notice": "Transfer a token between 2 addresses."
      }
    },
    "notice": "a puzzle",
    "version": 1
  },
  "argsData": "0x",
  "transaction": {
    "hash": "0x7ecf7a89ddd89a2700ace7029a537ff3286b217ac70ae6e87a5c0bd368c5b7d3",
    "nonce": "0x2",
    "origin": "0x61c461ecc993aadeb7e4b47e96d1b8cc37314b20"
  },
  "receipt": {
    "confirmations": 0,
    "blockHash": "0x9dc2f3668bdc3952ebefd1437ada9fa76c2b51e5eb49efd5b65c1165287bb615",
    "blockNumber": "0x18d7364",
    "transactionIndex": "0x0"
  }
}